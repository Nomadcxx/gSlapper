{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"gSlapper Documentation","text":"<p>gSlapper is a high-performance wallpaper manager for Wayland that combines the best of swww and mpvpaper. It uses GStreamer instead of libmpv, providing faster performance, better efficiency, and fixes memory leaks on NVIDIA Wayland systems while offering superior multi-monitor support.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation - Get gSlapper installed on your system</li> <li>Quick Start - Get up and running in minutes</li> <li>Getting Started Guide - Setup and configuration</li> <li>User Guide - Complete tutorial and features</li> <li>Advanced Topics - Prerequisites and advanced features</li> <li>Systemd Service - Automatic wallpaper restoration</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Video Wallpapers - Plays MP4, MKV, WebM, and other video formats</li> <li>Static Images - Supports JPEG, PNG, WebP, and GIF</li> <li>Fade Transitions - Smooth transitions between wallpapers</li> <li>Multi-Monitor - Works with multiple displays independently</li> <li>IPC Control - Change wallpapers at runtime via Unix socket</li> <li>Scaling Modes - Choose between fill, stretch, original, and panscan</li> <li>Wayland Native - Built for wlroots compositors like Hyprland and Sway</li> </ul>"},{"location":"#why-gstreamer","title":"Why GStreamer?","text":"<p>gSlapper replaces libmpv with GStreamer to solve memory leaks on NVIDIA Wayland systems, improve GPU resource management, and provide more reliable multi-monitor support. GStreamer offers mature Wayland/EGL integration and proper hardware acceleration.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>mpvpaper - Original inspiration</li> <li>swww - Static wallpaper inspiration</li> <li>GStreamer - Multimedia framework</li> <li>Clapper - GStreamer integration patterns</li> </ul>"},{"location":"systemd-service-setup/","title":"Systemd Service Setup for gSlapper","text":"<p>gSlapper can run as a systemd user service, similar to how <code>swww-daemon</code> works. This allows automatic wallpaper restoration on login.</p>"},{"location":"systemd-service-setup/#quick-setup","title":"Quick Setup","text":""},{"location":"systemd-service-setup/#1-create-environment-file","title":"1. Create Environment File","text":"<p>Required: Create <code>~/.config/gslapper/environment</code> with your Wayland display:</p> <pre><code>mkdir -p ~/.config/gslapper\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n</code></pre> <p>Finding your WAYLAND_DISPLAY: <pre><code>echo $WAYLAND_DISPLAY\n# Common values: wayland-0, wayland-1\n</code></pre></p>"},{"location":"systemd-service-setup/#2-set-initial-wallpaper","title":"2. Set Initial Wallpaper","text":"<p>Start gSlapper manually once to set your wallpaper (this saves state):</p> <pre><code># Single monitor\ngslapper -o \"loop\" DP-1 /path/to/video.mp4\n\n# All monitors (same wallpaper)\ngslapper -o \"loop\" '*' /path/to/video.mp4\n</code></pre> <p>Stop with <code>Ctrl+C</code>. The state is saved automatically.</p>"},{"location":"systemd-service-setup/#3-create-service-file","title":"3. Create Service File","text":"<p>Choose one of the following approaches:</p>"},{"location":"systemd-service-setup/#option-a-single-service-all-monitors-same-wallpaper","title":"Option A: Single Service (All Monitors - Same Wallpaper)","text":"<p>Create <code>~/.config/systemd/user/gslapper.service</code>:</p> <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service\nDocumentation=https://nomadcxx.github.io/gSlapper/\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore '*'\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\nTimeoutStopSec=30\n\n# CRITICAL: Wayland environment variables\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\n# Resource limits\nMemoryMax=512M\nCPUQuota=50%\n\n# Security\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=default.target\n</code></pre> <p>Enable and start: <pre><code>systemctl --user daemon-reload\nsystemctl --user enable --now gslapper.service\n</code></pre></p>"},{"location":"systemd-service-setup/#option-b-per-monitor-services-different-wallpapers","title":"Option B: Per-Monitor Services (Different Wallpapers)","text":"<p>Create <code>~/.config/systemd/user/gslapper@.service</code>:</p> <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service for %i\nDocumentation=https://nomadcxx.github.io/gSlapper/\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore %i\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\nTimeoutStopSec=30\n\n# CRITICAL: Wayland environment variables\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\n# Resource limits\nMemoryMax=512M\nCPUQuota=50%\n\n# Security\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=default.target\n</code></pre> <p>Set wallpapers per monitor: <pre><code># Set wallpaper on DP-1\ngslapper -o \"loop\" DP-1 /path/to/video1.mp4\n# Ctrl+C to stop (saves state)\n\n# Set wallpaper on DP-3\ngslapper -o \"fill\" DP-3 /path/to/image.jpg\n# Ctrl+C to stop (saves state)\n</code></pre></p> <p>Enable per monitor: <pre><code>systemctl --user daemon-reload\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-3.service\n</code></pre></p>"},{"location":"systemd-service-setup/#service-management","title":"Service Management","text":"<pre><code># Check status\nsystemctl --user status gslapper.service\n\n# View logs\njournalctl --user -u gslapper.service -f\n\n# Reload (saves state, restarts)\nsystemctl --user reload gslapper.service\n\n# Restart\nsystemctl --user restart gslapper.service\n\n# Stop\nsystemctl --user stop gslapper.service\n\n# Disable autostart\nsystemctl --user disable gslapper.service\n</code></pre>"},{"location":"systemd-service-setup/#how-it-works","title":"How It Works","text":"<ol> <li>Service starts with <code>--systemd --restore &lt;output&gt;</code> flags</li> <li>Restores state from <code>~/.local/state/gslapper/state-&lt;output&gt;.txt</code></li> <li>Resumes wallpaper at saved position (videos) or shows saved image</li> <li>On reload/stop saves current state automatically</li> <li>On restart restores from saved state</li> </ol>"},{"location":"systemd-service-setup/#state-files","title":"State Files","text":"<p>State files are saved automatically to: <pre><code>~/.local/state/gslapper/state-DP-1.txt\n~/.local/state/gslapper/state-DP-3.txt\n~/.local/state/gslapper/state.txt  (for '*' output)\n</code></pre></p> <p>Each file contains: <pre><code>version=1\noutput=DP-1\npath=/path/to/wallpaper.mp4\ntype=video\noptions=loop panscan=0.8\nposition=123.45\npaused=0\n</code></pre></p>"},{"location":"systemd-service-setup/#comparison-with-swww","title":"Comparison with swww","text":"<p>swww: - <code>swww-daemon</code> runs as a single daemon process - Systemd service: <code>ExecStart=/usr/bin/swww-daemon</code> - Automatic cache restoration on startup (built-in) - Manages all outputs in one process</p> <p>gSlapper: - One process per wallpaper (like mpvpaper) - Systemd service: <code>ExecStart=/usr/bin/gslapper --systemd --restore &lt;output&gt;</code> - Explicit state restoration via <code>--restore</code> flag - Each monitor can have its own service instance - More detailed state (video position, pause state, options)</p> <p>Why the difference: - swww is a daemon that stays alive - automatic cache restoration works naturally - gSlapper is one-shot process - needs systemd to restart and restore after reboot - Both approaches work, but gSlapper's systemd service is essential for persistence</p>"},{"location":"systemd-service-setup/#troubleshooting","title":"Troubleshooting","text":"<p>Service fails to start: - Check <code>journalctl --user -u gslapper.service</code> - Verify <code>~/.config/gslapper/environment</code> exists and has <code>WAYLAND_DISPLAY</code> - Ensure state file exists (set wallpaper manually first)</p> <p>Wallpaper not restoring: - Check state file exists: <code>ls ~/.local/state/gslapper/</code> - Verify path in state file still exists - Check service logs for errors</p> <p>Multiple monitors: - Use template service (<code>gslapper@.service</code>) for per-monitor instances - Or use single service with <code>'*'</code> for same wallpaper on all monitors</p>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>Advanced usage and configuration options for gSlapper.</p>"},{"location":"advanced/#before-you-start","title":"Before You Start","text":"<p>To use advanced features like transitions, IPC control, and multi-monitor setups, ensure you have:</p> <ul> <li>gSlapper installed on your system</li> <li>Wayland compositor running (Hyprland, Sway, etc.)</li> <li>Unix domain socket support in your compositor (for IPC)</li> </ul>"},{"location":"advanced/#advanced-topics_1","title":"Advanced Topics","text":"<ul> <li>Transitions - Smooth wallpaper transitions</li> <li>Multi-Monitor Setup - Independent display control</li> <li>Performance Tuning - Optimize GPU usage</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"advanced/multi-monitor/","title":"Multi-Monitor Setup","text":"<p>gSlapper provides full support for multiple displays, allowing you to set different wallpapers on each monitor or use the same wallpaper across all displays.</p>"},{"location":"advanced/multi-monitor/#listing-available-monitors","title":"Listing Available Monitors","text":"<p>Use the <code>-d</code> or <code>--help-output</code> option to list all available monitors:</p> <pre><code>gslapper -d\n</code></pre> <p>Output example: <pre><code>[*] Output: eDP-1  Identifier: InfoVision Optoelectronics\n[*] Output: DP-1   Identifier: Dell Inc. DELL U2718Q\n[*] Output: HDMI-1 Identifier: Samsung Electronics\n</code></pre></p>"},{"location":"advanced/multi-monitor/#single-monitor","title":"Single Monitor","text":"<p>Set wallpaper on a specific monitor:</p> <pre><code># By name\ngslapper DP-1 /path/to/video.mp4\n\n# By identifier (if name doesn't work)\ngslapper \"Dell Inc. DELL U2718Q\" /path/to/video.mp4\n</code></pre>"},{"location":"advanced/multi-monitor/#all-monitors","title":"All Monitors","text":"<p>Use <code>'*'</code> to set the same wallpaper on all monitors:</p> <pre><code>gslapper -o \"loop\" '*' /path/to/video.mp4\n</code></pre>"},{"location":"advanced/multi-monitor/#different-wallpapers-per-monitor","title":"Different Wallpapers per Monitor","text":"<p>Run multiple instances, one per monitor:</p> <pre><code># Monitor 1\ngslapper -f -o \"loop\" DP-1 /path/to/video1.mp4 &amp;\n\n# Monitor 2\ngslapper -f -o \"loop\" HDMI-1 /path/to/video2.mp4 &amp;\n\n# Monitor 3\ngslapper -f -o \"loop\" eDP-1 /path/to/image.jpg &amp;\n</code></pre>"},{"location":"advanced/multi-monitor/#ipc-control-per-monitor","title":"IPC Control per Monitor","text":"<p>Each monitor can have its own IPC socket:</p> <pre><code># Monitor 1 with IPC\ngslapper -I /tmp/gslapper-dp1.sock -o \"loop\" DP-1 video1.mp4 &amp;\n\n# Monitor 2 with IPC\ngslapper -I /tmp/gslapper-hdmi1.sock -o \"loop\" HDMI-1 video2.mp4 &amp;\n\n# Control each independently\necho \"pause\" | nc -U /tmp/gslapper-dp1.sock\necho \"change /path/to/new.mp4\" | nc -U /tmp/gslapper-hdmi1.sock\n</code></pre>"},{"location":"advanced/multi-monitor/#display-scaling","title":"Display Scaling","text":"<p>gSlapper automatically handles display scaling. Each monitor's scale factor is detected and applied correctly.</p>"},{"location":"advanced/multi-monitor/#recommended-approach","title":"Recommended Approach","text":"<p>For multi-monitor setups, we recommend one of the following (choose based on your needs):</p>"},{"location":"advanced/multi-monitor/#option-1-systemd-template-service-recommended","title":"Option 1: Systemd Template Service (Recommended)","text":"<p>Best for: Automatic startup, persistent wallpapers, reliable management</p> <p>Setup: <pre><code># Enable per-monitor services\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@HDMI-1.service\n</code></pre></p> <p>Advantages: - \u2705 Automatic startup on login - \u2705 Independent wallpaper restoration per monitor - \u2705 Automatic restart on failure - \u2705 Easy to manage with systemctl</p> <p>See also: Systemd Service Setup for full guide</p>"},{"location":"advanced/multi-monitor/#option-2-same-wallpaper-on-all-monitors","title":"Option 2: Same Wallpaper on All Monitors","text":"<p>Best for: Simple setup, single wallpaper across displays</p> <p>Setup: <pre><code>gslapper -o \"loop\" '*' /path/to/video.mp4\n</code></pre></p> <p>Advantages: - \u2705 Simple (one command) - \u2705 Low resource usage (single pipeline) - \u2705 Easy to change wallpaper</p>"},{"location":"advanced/multi-monitor/#option-3-manual-backgrounding","title":"Option 3: Manual Backgrounding","text":"<p>Best for: Testing, temporary setups, manual control</p> <p>Best Practices: 1. Use <code>-f</code> flag to background each instance 2. Use unique IPC socket paths for each monitor 3. Monitor GPU/CPU usage (multiple video wallpapers = higher usage) 4. Use startup script to manage multiple instances</p> <p>Setup (see Example Startup Script below)</p>"},{"location":"advanced/multi-monitor/#example-startup-script","title":"Example Startup Script","text":"<pre><code>#!/bin/bash\n# ~/.local/bin/start-wallpapers.sh\n\n# Kill existing instances\npkill gslapper\n\n# Wait a moment\nsleep 1\n\n# Start wallpapers for each monitor\ngslapper -f -I /tmp/gslapper-dp1.sock -o \"loop\" DP-1 ~/Videos/wallpaper1.mp4 &amp;\nsleep 0.5\n\ngslapper -f -I /tmp/gslapper-hdmi1.sock -o \"loop\" HDMI-1 ~/Videos/wallpaper2.mp4 &amp;\nsleep 0.5\n\ngslapper -f -I /tmp/gslapper-edp1.sock -o \"fill\" eDP-1 ~/Pictures/wallpaper.jpg &amp;\n</code></pre>"},{"location":"advanced/multi-monitor/#systemd-user-service","title":"Systemd User Service","text":"<p>Create <code>~/.config/systemd/user/wallpapers.service</code>:</p> <pre><code>[Unit]\nDescription=Wallpapers for all monitors\nAfter=graphical-session.target\n\n[Service]\nType=forking\nExecStart=/home/user/.local/bin/start-wallpapers.sh\nExecStop=/usr/bin/pkill gslapper\nRestart=on-failure\n\n[Install]\nWantedBy=default.target\n</code></pre> <p>Enable and start: <pre><code>systemctl --user enable wallpapers.service\nsystemctl --user start wallpapers.service\n</code></pre></p>"},{"location":"advanced/performance/","title":"Performance Tuning","text":"<p>gSlapper is designed to be efficient, but there are several options to optimize performance for your system.</p>"},{"location":"advanced/performance/#frame-rate-control","title":"Frame Rate Control","text":""},{"location":"advanced/performance/#frame-rate-cap","title":"Frame Rate Cap","text":"<p>Control the maximum frame rate to reduce GPU/CPU usage:</p> <pre><code>gslapper --fps-cap 30 -o \"loop\" DP-1 video.mp4\n</code></pre> <p>Available options: - <code>30</code> - 30 FPS (default, good balance) - <code>60</code> - 60 FPS (smoother, more resource intensive) - <code>100</code> - 100 FPS (maximum smoothness)</p>"},{"location":"advanced/performance/#when-to-adjust","title":"When to Adjust","text":"<ul> <li>Lower FPS (30): Older hardware, battery-powered devices, multiple monitors</li> <li>Higher FPS (60-100): High-end GPUs, single monitor, smooth video playback</li> </ul>"},{"location":"advanced/performance/#auto-pausestop","title":"Auto-Pause/Stop","text":"<p>Reduce resource usage when wallpapers are hidden:</p>"},{"location":"advanced/performance/#auto-pause","title":"Auto-Pause","text":"<p>Pauses playback when certain applications are fullscreen:</p> <pre><code>gslapper -p -o \"loop\" DP-1 video.mp4\n</code></pre> <p>Configure apps in <code>~/.config/mpvpaper/pauselist</code>: <pre><code>firefox\nchromium\nmpv\nvlc\n</code></pre></p>"},{"location":"advanced/performance/#auto-stop","title":"Auto-Stop","text":"<p>Completely stops playback when wallpaper is hidden:</p> <pre><code>gslapper -s -o \"loop\" DP-1 video.mp4\n</code></pre> <p>Configure apps in <code>~/.config/mpvpaper/stoplist</code>: <pre><code>games\n</code></pre></p>"},{"location":"advanced/performance/#video-optimization","title":"Video Optimization","text":""},{"location":"advanced/performance/#codec-selection","title":"Codec Selection","text":"<p>Use hardware-accelerated codecs when available:</p> <ul> <li>H.264 - Widely supported, good performance</li> <li>H.265/HEVC - Better compression, requires more processing</li> <li>VP9 - Open format, good compression</li> </ul>"},{"location":"advanced/performance/#video-resolution","title":"Video Resolution","text":"<p>Lower resolution videos use fewer resources:</p> <pre><code># Use 1080p instead of 4K for better performance\ngslapper -o \"loop\" DP-1 video_1080p.mp4\n</code></pre>"},{"location":"advanced/performance/#image-optimization","title":"Image Optimization","text":""},{"location":"advanced/performance/#static-images","title":"Static Images","text":"<p>Static images are very efficient. For best performance:</p> <ul> <li>Use appropriate resolution (don't use 8K images on 1080p displays)</li> <li>Prefer JPEG for photos (smaller file size)</li> <li>Use PNG only when transparency is needed</li> </ul>"},{"location":"advanced/performance/#transitions","title":"Transitions","text":"<p>Transitions add some CPU overhead:</p> <ul> <li>Shorter durations (0.5-1.0s) use fewer resources</li> <li>Longer durations (3.0s+) are smoother but use more CPU</li> <li>Disable transitions if performance is critical</li> </ul>"},{"location":"advanced/performance/#multi-monitor-performance","title":"Multi-Monitor Performance","text":"<p>Running multiple instances uses more resources:</p>"},{"location":"advanced/performance/#tips","title":"Tips","text":"<ol> <li>Mix static and video - Use static images on secondary monitors</li> <li>Lower FPS on secondary - Use <code>--fps-cap 30</code> on non-primary monitors</li> <li>Use auto-pause - Pause wallpapers when not visible</li> </ol> <pre><code># Primary monitor: 60 FPS video\ngslapper --fps-cap 60 -o \"loop\" DP-1 video.mp4 &amp;\n\n# Secondary monitor: 30 FPS video\ngslapper --fps-cap 30 -o \"loop\" HDMI-1 video2.mp4 &amp;\n\n# Tertiary monitor: Static image (most efficient)\ngslapper -o \"fill\" eDP-1 image.jpg &amp;\n</code></pre>"},{"location":"advanced/performance/#gpu-acceleration","title":"GPU Acceleration","text":"<p>gSlapper uses GStreamer's hardware acceleration when available:</p>"},{"location":"advanced/performance/#nvidia","title":"NVIDIA","text":"<p>Ensure proper drivers and GStreamer plugins: <pre><code># Arch Linux\nsudo pacman -S gst-plugins-bad gst-plugins-ugly\n\n# Verify hardware acceleration\ngst-inspect-1.0 nvdec\n</code></pre></p>"},{"location":"advanced/performance/#amdintel","title":"AMD/Intel","text":"<p>Hardware acceleration is typically automatic with Mesa drivers.</p>"},{"location":"advanced/performance/#memory-usage","title":"Memory Usage","text":""},{"location":"advanced/performance/#video-wallpapers","title":"Video Wallpapers","text":"<ul> <li>Memory usage depends on video resolution and codec</li> <li>1080p videos: ~50-100 MB</li> <li>4K videos: ~200-400 MB</li> </ul>"},{"location":"advanced/performance/#static-images_1","title":"Static Images","text":"<ul> <li>Very low memory usage</li> <li>Typically &lt; 50 MB regardless of image size</li> </ul>"},{"location":"advanced/performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"advanced/performance/#verbose-output","title":"Verbose Output","text":"<p>Use verbose mode to see performance information:</p> <pre><code>gslapper -vv -o \"loop\" DP-1 video.mp4\n</code></pre> <p>Look for: - Frame processing times - Texture allocation messages - Pipeline state changes</p>"},{"location":"advanced/performance/#system-monitoring","title":"System Monitoring","text":"<p>Monitor resource usage:</p> <pre><code># CPU and memory\nhtop\n\n# GPU usage (NVIDIA)\nnvidia-smi -l 1\n\n# GPU usage (AMD/Intel)\nradeontop  # or intel_gpu_top\n</code></pre>"},{"location":"advanced/performance/#troubleshooting-performance-issues","title":"Troubleshooting Performance Issues","text":""},{"location":"advanced/performance/#high-cpu-usage","title":"High CPU Usage","text":"<ol> <li>Lower frame rate cap: <code>--fps-cap 30</code></li> <li>Use auto-pause: <code>-p</code></li> <li>Reduce video resolution</li> <li>Disable transitions</li> </ol>"},{"location":"advanced/performance/#high-memory-usage","title":"High Memory Usage","text":"<ol> <li>Use static images instead of videos</li> <li>Lower video resolution</li> <li>Check for memory leaks (restart periodically)</li> </ol>"},{"location":"advanced/performance/#stutteringframe-drops","title":"Stuttering/Frame Drops","text":"<ol> <li>Lower frame rate cap</li> <li>Check GPU drivers are up to date</li> <li>Ensure hardware acceleration is working</li> <li>Close other GPU-intensive applications</li> </ol>"},{"location":"advanced/transitions/","title":"Transitions","text":"<p>gSlapper supports smooth fade transitions between static images, providing a polished wallpaper switching experience.</p>"},{"location":"advanced/transitions/#enabling-transitions","title":"Enabling Transitions","text":"<p>Transitions are enabled via command-line options:</p> <pre><code>gslapper --transition-type fade --transition-duration 2.0 -I /tmp/gslapper.sock DP-1 image.jpg\n</code></pre>"},{"location":"advanced/transitions/#options","title":"Options","text":"<ul> <li><code>--transition-type TYPE</code> - Transition effect type</li> <li><code>none</code> (default) - No transition</li> <li> <p><code>fade</code> - Smooth fade between images</p> </li> <li> <p><code>--transition-duration SECS</code> - Transition duration in seconds (default: 0.5)</p> </li> </ul>"},{"location":"advanced/transitions/#requirements","title":"Requirements","text":"<ul> <li>IPC must be enabled - Transitions require the <code>-I</code> or <code>--ipc-socket</code> option</li> <li>Static images only - Transitions work between images, not videos</li> <li>Same or different aspect ratios - Both images will correctly fill the screen</li> </ul>"},{"location":"advanced/transitions/#usage","title":"Usage","text":""},{"location":"advanced/transitions/#basic-fade-transition","title":"Basic Fade Transition","text":"<pre><code># Start with first image\ngslapper --transition-type fade --transition-duration 2.0 -I /tmp/gslapper.sock DP-1 image1.jpg\n\n# Switch to second image (transition happens automatically)\necho \"change /path/to/image2.jpg\" | nc -U /tmp/gslapper.sock\n</code></pre>"},{"location":"advanced/transitions/#different-aspect-ratios","title":"Different Aspect Ratios","text":"<p>Transitions handle images with different aspect ratios correctly:</p> <pre><code># 4:3 image -&gt; 16:9 image\ngslapper --transition-type fade --transition-duration 1.5 -I /tmp/gslapper.sock DP-1 4x3_image.jpg\necho \"change /path/to/16x9_image.jpg\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Both images will fill the screen properly during the transition, with no letterboxing.</p>"},{"location":"advanced/transitions/#how-it-works","title":"How It Works","text":"<ol> <li>Capture - When a transition starts, the current image is captured</li> <li>Load - The new image is loaded asynchronously</li> <li>Resize - Both images are resized to display resolution with fill mode</li> <li>Blend - Images are blended pixel-by-pixel using CPU-based alpha blending</li> <li>Complete - Transition completes when duration is reached</li> </ol>"},{"location":"advanced/transitions/#supported-formats","title":"Supported Formats","text":"<p>Transitions work with all supported image formats: - JPEG (.jpg, .jpeg) - PNG (.png) - WebP (.webp) - GIF (.gif) - First frame only</p>"},{"location":"advanced/transitions/#performance","title":"Performance","text":"<ul> <li>CPU-based blending - Uses efficient pixel blending similar to swww</li> <li>Display resolution - Blends at logical display resolution for optimal performance</li> <li>Smooth animation - Frame rate capped to ensure smooth transitions</li> </ul>"},{"location":"advanced/transitions/#limitations","title":"Limitations","text":"<ul> <li>Transitions only work between static images</li> <li>Video wallpapers do not support transitions</li> <li>IPC socket must be enabled</li> <li>Rapid transitions (multiple changes in quick succession) may cancel previous transitions</li> </ul>"},{"location":"advanced/transitions/#examples","title":"Examples","text":""},{"location":"advanced/transitions/#slideshow-script","title":"Slideshow Script","text":"<pre><code>#!/bin/bash\nSOCKET=\"/tmp/gslapper.sock\"\nIMAGES=(\n    \"/path/to/image1.jpg\"\n    \"/path/to/image2.png\"\n    \"/path/to/image3.webp\"\n)\n\n# Start with first image\ngslapper --transition-type fade --transition-duration 2.0 -I \"$SOCKET\" DP-1 \"${IMAGES[0]}\" &amp;\nsleep 3\n\n# Cycle through images\nfor img in \"${IMAGES[@]:1}\"; do\n    echo \"change $img\" | nc -U \"$SOCKET\"\n    sleep 3\ndone\n</code></pre>"},{"location":"advanced/transitions/#random-wallpaper-with-transition","title":"Random Wallpaper with Transition","text":"<pre><code>#!/bin/bash\nSOCKET=\"/tmp/gslapper.sock\"\nWALLPAPER_DIR=\"/home/user/Pictures/wallpapers\"\n\n# Get random image\nRANDOM_IMG=$(find \"$WALLPAPER_DIR\" -type f \\( -iname \"*.jpg\" -o -iname \"*.png\" -o -iname \"*.webp\" \\) | shuf -n 1)\n\n# Start or change wallpaper\nif pgrep -x gslapper &gt; /dev/null; then\n    echo \"change $RANDOM_IMG\" | nc -U \"$SOCKET\"\nelse\n    gslapper --transition-type fade --transition-duration 1.5 -I \"$SOCKET\" DP-1 \"$RANDOM_IMG\"\nfi\n</code></pre>"},{"location":"advanced/troubleshooting/","title":"Troubleshooting","text":"<p>Common issues and their solutions.</p>"},{"location":"advanced/troubleshooting/#video-wont-play","title":"Video Won't Play","text":""},{"location":"advanced/troubleshooting/#pipeline-failed-to-reach-playing-state","title":"\"Pipeline failed to reach playing state\"","text":"<p>Cause: Missing codec support</p> <p>Solution: Install GStreamer codec plugins:</p> <pre><code># Arch Linux\nsudo pacman -S gst-plugins-ugly gst-libav\n\n# Ubuntu/Debian\nsudo apt install gstreamer1.0-plugins-ugly gstreamer1.0-libav\n</code></pre>"},{"location":"advanced/troubleshooting/#video-plays-but-no-display","title":"Video Plays But No Display","text":"<p>Cause: Wayland compositor not detected or EGL initialization failed</p> <p>Solution: 1. Verify you're running a Wayland compositor (Hyprland, Sway, etc.) 2. Check EGL support: <code>gst-inspect-1.0 egl</code> 3. Try with verbose output: <code>gslapper -vv DP-1 video.mp4</code></p>"},{"location":"advanced/troubleshooting/#video-plays-but-freezes","title":"Video Plays But Freezes","text":"<p>Cause: GStreamer pipeline issues or resource exhaustion</p> <p>Solution: 1. Check system resources: <code>htop</code> 2. Restart gSlapper 3. Try a different video file 4. Check logs with <code>-vv</code> flag</p>"},{"location":"advanced/troubleshooting/#image-issues","title":"Image Issues","text":""},{"location":"advanced/troubleshooting/#image-not-displaying","title":"Image Not Displaying","text":"<p>Cause: Unsupported format or file corruption</p> <p>Solution: 1. Verify file format is supported (JPEG, PNG, WebP, GIF) 2. Check file is not corrupted: <code>file /path/to/image.jpg</code> 3. Try with another image 4. Use verbose mode: <code>gslapper -vv DP-1 image.jpg</code></p>"},{"location":"advanced/troubleshooting/#image-shows-letterboxing","title":"Image Shows Letterboxing","text":"<p>Cause: Wrong scaling mode</p> <p>Solution: Use fill mode: <pre><code>gslapper -o \"fill\" DP-1 image.jpg\n</code></pre></p>"},{"location":"advanced/troubleshooting/#image-looks-distorted","title":"Image Looks Distorted","text":"<p>Cause: Stretch mode enabled</p> <p>Solution: Use fill mode instead: <pre><code>gslapper -o \"fill\" DP-1 image.jpg\n</code></pre></p>"},{"location":"advanced/troubleshooting/#transition-issues","title":"Transition Issues","text":""},{"location":"advanced/troubleshooting/#transitions-not-working","title":"Transitions Not Working","text":"<p>Cause: IPC not enabled or transitions disabled</p> <p>Solution: 1. Enable IPC: <code>-I /tmp/gslapper.sock</code> 2. Enable transitions: <code>--transition-type fade</code> 3. Verify both are set: <pre><code>gslapper --transition-type fade --transition-duration 2.0 -I /tmp/gslapper.sock DP-1 image.jpg\n</code></pre></p>"},{"location":"advanced/troubleshooting/#transition-shows-letterboxing","title":"Transition Shows Letterboxing","text":"<p>Cause: This was a bug that has been fixed in recent versions</p> <p>Solution: Update to latest version. Both images should fill the screen correctly.</p>"},{"location":"advanced/troubleshooting/#transition-too-fastslow","title":"Transition Too Fast/Slow","text":"<p>Cause: Duration not set correctly</p> <p>Solution: Adjust duration: <pre><code># Faster (0.5 seconds)\ngslapper --transition-type fade --transition-duration 0.5 -I /tmp/sock DP-1 image.jpg\n\n# Slower (3.0 seconds)\ngslapper --transition-type fade --transition-duration 3.0 -I /tmp/sock DP-1 image.jpg\n</code></pre></p>"},{"location":"advanced/troubleshooting/#ipc-issues","title":"IPC Issues","text":""},{"location":"advanced/troubleshooting/#connection-refused-or-no-such-file","title":"\"Connection refused\" or \"No such file\"","text":"<p>Cause: IPC socket not created or gSlapper not running</p> <p>Solution: 1. Verify gSlapper is running: <code>pgrep gslapper</code> 2. Check socket exists: <code>ls -l /tmp/gslapper.sock</code> 3. Ensure IPC was enabled: <code>gslapper -I /tmp/gslapper.sock ...</code></p>"},{"location":"advanced/troubleshooting/#ipc-commands-not-working","title":"IPC Commands Not Working","text":"<p>Cause: Wrong socket path or permission issues</p> <p>Solution: 1. Use correct socket path 2. Check permissions: <code>ls -l /tmp/gslapper.sock</code> 3. Try with socat instead of nc: <pre><code>echo \"query\" | socat - UNIX-CONNECT:/tmp/gslapper.sock\n</code></pre></p>"},{"location":"advanced/troubleshooting/#multi-monitor-issues","title":"Multi-Monitor Issues","text":""},{"location":"advanced/troubleshooting/#wrong-monitor-selected","title":"Wrong Monitor Selected","text":"<p>Cause: Monitor name mismatch</p> <p>Solution: 1. List available monitors: <code>gslapper -d</code> 2. Use exact name or identifier 3. Try with <code>'*'</code> for all monitors</p>"},{"location":"advanced/troubleshooting/#wallpaper-not-showing-on-all-monitors","title":"Wallpaper Not Showing on All Monitors","text":"<p>Cause: Multiple instances interfering</p> <p>Solution: 1. Kill all instances: <code>pkill gslapper</code> 2. Start fresh with <code>'*'</code>: <pre><code>gslapper -o \"loop\" '*' video.mp4\n</code></pre></p>"},{"location":"advanced/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"advanced/troubleshooting/#high-cpu-usage","title":"High CPU Usage","text":"<p>See Performance Tuning for detailed solutions.</p> <p>Quick fixes: - Lower FPS: <code>--fps-cap 30</code> - Use auto-pause: <code>-p</code> - Use static images instead of videos</p>"},{"location":"advanced/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Cause: Large video files or memory leak</p> <p>Solution: 1. Use lower resolution videos 2. Restart gSlapper periodically 3. Check for updates (memory leaks are fixed in newer versions)</p>"},{"location":"advanced/troubleshooting/#build-issues","title":"Build Issues","text":""},{"location":"advanced/troubleshooting/#meson-command-not-found","title":"\"meson: command not found\"","text":"<p>Solution: Install build dependencies: <pre><code># Arch Linux\nsudo pacman -S meson ninja\n\n# Ubuntu/Debian\nsudo apt install meson ninja-build\n</code></pre></p>"},{"location":"advanced/troubleshooting/#wayland-protocols-not-found","title":"\"wayland-protocols not found\"","text":"<p>Solution: Install Wayland development packages: <pre><code># Arch Linux\nsudo pacman -S wayland-protocols\n\n# Ubuntu/Debian\nsudo apt install wayland-protocols\n</code></pre></p>"},{"location":"advanced/troubleshooting/#compilation-errors","title":"Compilation Errors","text":"<p>Solution: 1. Ensure all dependencies are installed 2. Clean build directory: <code>rm -rf build &amp;&amp; meson setup build</code> 3. Check for error messages in build output</p>"},{"location":"advanced/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"advanced/troubleshooting/#verbose-output","title":"Verbose Output","text":"<p>Always include verbose output when reporting issues:</p> <pre><code>gslapper -vv DP-1 video.mp4 &gt; /tmp/gslapper.log 2&gt;&amp;1\n</code></pre>"},{"location":"advanced/troubleshooting/#system-information","title":"System Information","text":"<p>Include when reporting issues: - Distribution and version - Wayland compositor (Hyprland, Sway, etc.) - GPU and drivers - GStreamer version: <code>gst-launch-1.0 --version</code></p>"},{"location":"advanced/troubleshooting/#reporting-issues","title":"Reporting Issues","text":"<ol> <li>Check existing issues on GitHub</li> <li>Include verbose log output</li> <li>Include system information</li> <li>Describe steps to reproduce</li> </ol>"},{"location":"development/api-reference/","title":"API Reference","text":"<p>This document provides a comprehensive reference for gSlapper's public APIs, internal functions, and data structures.</p> <p>Note: This is a developer-facing API reference. For user-facing command-line options, see Command Line Options.</p>"},{"location":"development/api-reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>IPC API</li> <li>State Management API</li> <li>Logging API</li> <li>Internal APIs</li> <li>Wayland Integration</li> <li>GStreamer Pipeline</li> <li>Rendering</li> <li>Command-Line Parsing</li> </ul>"},{"location":"development/api-reference/#ipc-api","title":"IPC API","text":"<p>The IPC (Inter-Process Communication) API allows runtime control of gSlapper via Unix domain sockets.</p>"},{"location":"development/api-reference/#overview","title":"Overview","text":"<p>The IPC system uses a client-server model: - Server: Runs within gSlapper main process - Clients: External processes (scripts, user tools) - Protocol: Text-based commands over Unix socket</p>"},{"location":"development/api-reference/#initialization","title":"Initialization","text":""},{"location":"development/api-reference/#ipc_initconst-char-socket_path","title":"<code>ipc_init(const char *socket_path)</code>","text":"<p>Initialize IPC server with specified socket path.</p> <p>Parameters: - <code>socket_path</code> - Path to Unix socket (e.g., <code>/tmp/gslapper.sock</code>)</p> <p>Returns: - <code>true</code> on success - <code>false</code> on failure</p> <p>Thread Safety: Thread-safe (creates dedicated thread)</p> <p>Example: <pre><code>#include \"ipc.h\"\n\nbool success = ipc_init(\"/tmp/gslapper.sock\");\nif (!success) {\n    fprintf(stderr, \"Failed to initialize IPC server\\n\");\n}\n</code></pre></p>"},{"location":"development/api-reference/#ipc_shutdownvoid","title":"<code>ipc_shutdown(void)</code>","text":"<p>Shutdown IPC server and cleanup resources.</p> <p>Parameters: None</p> <p>Returns: void</p> <p>Thread Safety: Thread-safe (uses internal locks)</p> <p>Behavior: - Closes all client connections - Unlinks socket file - Joins server thread - Frees all allocated resources</p> <p>Example: <pre><code>// At program exit or on signal\nipc_shutdown();\n</code></pre></p>"},{"location":"development/api-reference/#wakeup-mechanism","title":"Wakeup Mechanism","text":""},{"location":"development/api-reference/#ipc_get_wakeup_fdvoid","title":"<code>ipc_get_wakeup_fd(void)</code>","text":"<p>Get file descriptor for the wakeup pipe (used by main event loop).</p> <p>Returns: - File descriptor (int) for wakeup pipe - <code>-1</code> if IPC not initialized</p> <p>Purpose: - Allows main loop to monitor IPC activity via <code>poll()</code> or <code>select()</code> - Writing to this pipe wakes up the main loop when new commands arrive</p> <p>Example: <pre><code>#include &lt;poll.h&gt;\n\n// In main event loop\nstruct pollfd fds[2];\nfds[0].fd = wl_display_get_fd(display);\nfds[0].events = POLLIN;\nfds[1].fd = ipc_get_wakeup_fd();\nfds[1].events = POLLIN;\n\nwhile (running) {\n    poll(fds, 2, -1);\n    // Handle events...\n}\n</code></pre></p>"},{"location":"development/api-reference/#ipc_drain_wakeupvoid","title":"<code>ipc_drain_wakeup(void)</code>","text":"<p>Drain the wakeup pipe (call before processing commands).</p> <p>Parameters: None</p> <p>Returns: void</p> <p>Purpose: - Clear pending data from wakeup pipe - Prevents repeated wakeups for same event</p> <p>Example: <pre><code>// After poll() returns with IPC event\nif (fds[1].revents &amp; POLLIN) {\n    ipc_drain_wakeup();  // Clear pipe\n\n    // Now process commands\n    ipc_command_t *cmd = ipc_dequeue_command();\n    // ...\n}\n</code></pre></p>"},{"location":"development/api-reference/#command-queue","title":"Command Queue","text":""},{"location":"development/api-reference/#ipc_dequeue_commandvoid","title":"<code>ipc_dequeue_command(void)</code>","text":"<p>Dequeue next command from internal queue.</p> <p>Returns: - Pointer to <code>ipc_command_t</code> structure - <code>NULL</code> if queue empty</p> <p>Responsibility: Caller must free: - <code>cmd-&gt;cmd_line</code> (string) - Command structure itself (<code>free(cmd)</code>)</p> <p>Thread Safety: Thread-safe (uses mutex-protected queue)</p> <p>Example: <pre><code>while ((cmd = ipc_dequeue_command()) != NULL) {\n    // Process cmd-&gt;cmd_line\n    // Send response to cmd-&gt;client_fd\n    ipc_send_response(cmd-&gt;client_fd, \"OK\\n\");\n\n    // Cleanup\n    free(cmd-&gt;cmd_line);\n    free(cmd);\n}\n</code></pre></p>"},{"location":"development/api-reference/#ipc_send_responseint-client_fd-const-char-response","title":"<code>ipc_send_response(int client_fd, const char *response)</code>","text":"<p>Send response to IPC client (thread-safe).</p> <p>Parameters: - <code>client_fd</code> - File descriptor of client socket - <code>response</code> - Response string to send</p> <p>Returns: void</p> <p>Thread Safety: Thread-safe</p> <p>Format: Responses follow this format: - Success: <code>OK</code> or <code>OK: &lt;message&gt;</code> - Error: <code>ERROR: &lt;message&gt;</code> - Query: <code>STATUS: &lt;state&gt; &lt;type&gt; &lt;path&gt;</code> - Transition: <code>TRANSITION: &lt;type&gt; &lt;enabled|disabled&gt; &lt;duration&gt;</code></p> <p>Example: <pre><code>ipc_send_response(client_fd, \"OK: Wallpaper changed\\n\");\nipc_send_response(client_fd, \"ERROR: File not found\\n\");\nipc_send_response(client_fd, \"STATUS: playing video /path/to/video.mp4\\n\");\n</code></pre></p>"},{"location":"development/api-reference/#ipc-commands","title":"IPC Commands","text":""},{"location":"development/api-reference/#available-commands","title":"Available Commands","text":"Command Parameters Response Description <code>pause</code> None <code>OK</code> Pause video playback <code>resume</code> None <code>OK</code> Resume paused playback <code>stop</code> None <code>OK</code> Stop gSlapper (exits) <code>query</code> None <code>STATUS: &lt;state&gt; &lt;type&gt; &lt;path&gt;</code> Get current wallpaper state <code>change &lt;path&gt;</code> File path <code>OK</code> or <code>OK: transition started</code> Change wallpaper <code>set-transition &lt;type&gt;</code> <code>none</code> or <code>fade</code> <code>OK</code> or <code>ERROR</code> Set transition effect <code>set-transition-duration &lt;secs&gt;</code> 0.0-5.0 seconds <code>OK</code> or <code>ERROR</code> Set transition duration <code>get-transition</code> None <code>TRANSITION: &lt;type&gt; &lt;enabled&gt; &lt;duration&gt;</code> Query transition settings"},{"location":"development/api-reference/#example-client-code","title":"Example Client Code","text":"<pre><code>#include &lt;sys/socket.h&gt;\n#include &lt;sys/un.h&gt;\n\nint connect_to_ipc(const char *socket_path) {\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    struct sockaddr_un addr;\n    memset(&amp;addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);\n\n    if (connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {\n        return -1;\n    }\n    return fd;\n}\n\nvoid send_ipc_command(int fd, const char *cmd) {\n    write(fd, cmd, strlen(cmd));\n\n    char response[1024];\n    ssize_t n = read(fd, response, sizeof(response) - 1);\n    if (n &gt; 0) {\n        response[n] = '\\0';\n        printf(\"Response: %s\\n\", response);\n    }\n}\n\nint main() {\n    int fd = connect_to_ipc(\"/tmp/gslapper.sock\");\n    if (fd &lt; 0) {\n        perror(\"Failed to connect\");\n        return 1;\n    }\n\n    send_ipc_command(fd, \"pause\\n\");\n    send_ipc_command(fd, \"query\\n\");\n    send_ipc_command(fd, \"change /path/to/new/video.mp4\\n\");\n\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"development/api-reference/#data-structures","title":"Data Structures","text":""},{"location":"development/api-reference/#ipc_command_t","title":"<code>ipc_command_t</code>","text":"<pre><code>typedef struct ipc_command {\n    char *cmd_line;          // Full command string from client\n    int client_fd;            // Client socket file descriptor\n    struct ipc_command *next;  // Next command in queue (linked list)\n} ipc_command_t;\n</code></pre> <p>Usage: - Internal to IPC system (queued by server thread) - Dequeued by main thread for processing - Must be freed by caller after processing</p>"},{"location":"development/api-reference/#preload_entry_t","title":"<code>preload_entry_t</code>","text":"<pre><code>typedef struct preload_entry {\n    char *path;              // File path of preloaded image\n    gpointer frame_data;       // GLib pointer to frame data\n    gsize frame_size;         // Size of frame data in bytes\n    gint width;               // Image width in pixels\n    gint height;              // Image height in pixels\n    struct preload_entry *next; // Next entry in cache (linked list)\n} preload_entry_t;\n</code></pre> <p>Note: Currently reserved for future implementation (see TO_IMPLEMENT.md).</p>"},{"location":"development/api-reference/#state-management-api","title":"State Management API","text":"<p>The state management API provides persistent storage and retrieval of wallpaper configuration.</p>"},{"location":"development/api-reference/#overview_1","title":"Overview","text":"<p>State is saved as simple key=value text files (not JSON): - Location: <code>~/.local/state/gslapper/state-&lt;output&gt;.txt</code> - Format: Human-readable text - Atomic writes: Uses temp file + rename - Thread safety: File locking prevents corruption</p>"},{"location":"development/api-reference/#data-structures_1","title":"Data Structures","text":""},{"location":"development/api-reference/#wallpaper_state","title":"<code>wallpaper_state</code>","text":"<pre><code>struct wallpaper_state {\n    char *output;        // Monitor name (e.g., \"DP-1\", \"DP-3\")\n    char *path;         // Full path to video or image file\n    bool is_image;      // true = static image, false = video\n    char *options;       // GStreamer options string (e.g., \"loop panscan=0.8\")\n    double position;    // Video position in seconds (0.0 for images)\n    bool paused;        // Pause state for videos (false by default)\n};\n</code></pre> <p>Example State File (<code>state-DP-1.txt</code>): <pre><code>version=1\noutput=DP-1\npath=/home/user/Videos/wallpaper.mp4\nis_image=false\noptions=loop panscan=0.8\nposition=123.45\npaused=0\n</code></pre></p>"},{"location":"development/api-reference/#path-resolution","title":"Path Resolution","text":""},{"location":"development/api-reference/#get_state_file_pathconst-char-output_name","title":"<code>get_state_file_path(const char *output_name)</code>","text":"<p>Generate state file path for given output.</p> <p>Parameters: - <code>output_name</code> - Monitor name (e.g., \"DP-1\"), or <code>NULL</code> for default</p> <p>Returns: - Dynamically allocated string (must be freed by caller) - <code>NULL</code> on failure</p> <p>Path Resolution Logic: 1. Check <code>XDG_STATE_HOME</code> environment variable 2. If not set, use <code>$HOME/.local/state/gslapper/</code> 3. Append <code>state-&lt;output_name&gt;.txt</code> (or <code>state.txt</code> if <code>NULL</code>)</p> <p>Example: <pre><code>#include \"state.h\"\n\nchar *path = get_state_file_path(\"DP-1\");\nif (path) {\n    printf(\"State file: %s\\n\", path);\n    free(path);\n}\n</code></pre></p>"},{"location":"development/api-reference/#state-file-operations","title":"State File Operations","text":""},{"location":"development/api-reference/#save_state_fileconst-char-path-const-struct-wallpaper_state-state","title":"<code>save_state_file(const char *path, const struct wallpaper_state *state)</code>","text":"<p>Save wallpaper state to file.</p> <p>Parameters: - <code>path</code> - Full path to state file - <code>state</code> - Pointer to <code>wallpaper_state</code> structure</p> <p>Returns: - <code>0</code> on success - <code>-1</code> on failure</p> <p>Behavior: 1. Create backup of existing file (if any) 2. Write to temporary file (<code>.tmp</code> suffix) 3. Verify write completed 4. Atomic rename (temp \u2192 actual file) 5. Set permissions to <code>0600</code> (user-only) 6. Use file locking to prevent concurrent writes</p> <p>Example: <pre><code>struct wallpaper_state state = {\n    .output = \"DP-1\",\n    .path = \"/home/user/Videos/wallpaper.mp4\",\n    .is_image = false,\n    .options = \"loop panscan=0.8\",\n    .position = 123.45,\n    .paused = false\n};\n\nchar *state_path = get_state_file_path(\"DP-1\");\nif (state_path &amp;&amp; save_state_file(state_path, &amp;state) == 0) {\n    printf(\"State saved successfully\\n\");\n}\nfree(state_path);\n</code></pre></p>"},{"location":"development/api-reference/#load_state_fileconst-char-path-struct-wallpaper_state-state","title":"<code>load_state_file(const char *path, struct wallpaper_state *state)</code>","text":"<p>Load wallpaper state from file.</p> <p>Parameters: - <code>path</code> - Full path to state file - <code>state</code> - Pointer to <code>wallpaper_state</code> structure to fill</p> <p>Returns: - <code>0</code> on success - <code>-1</code> on failure (file not found, parse error, etc.)</p> <p>Behavior: 1. Open and lock file (shared lock) 2. Read key=value pairs line by line 3. Parse and populate <code>state</code> structure 4. Validate file paths exist 5. Unlock and close file</p> <p>Parsed Keys: - <code>version</code> - State file version (currently 1) - <code>output</code> - Monitor name - <code>path</code> - Video/image file path - <code>is_image</code> - Boolean (0 or 1) - <code>options</code> - GStreamer options string - <code>position</code> - Video position in seconds - <code>paused</code> - Pause state (0 or 1)</p> <p>Example: <pre><code>struct wallpaper_state state;\nchar *state_path = get_state_file_path(\"DP-1\");\n\nif (state_path &amp;&amp; load_state_file(state_path, &amp;state) == 0) {\n    printf(\"Restoring: %s\\n\", state.path);\n    printf(\"Options: %s\\n\", state.options);\n    printf(\"Position: %.2f\\n\", state.position);\n}\n</code></pre></p>"},{"location":"development/api-reference/#free_wallpaper_statestruct-wallpaper_state-state","title":"<code>free_wallpaper_state(struct wallpaper_state *state)</code>","text":"<p>Free all dynamically allocated memory in <code>wallpaper_state</code> structure.</p> <p>Parameters: - <code>state</code> - Pointer to <code>wallpaper_state</code> structure</p> <p>Returns: void</p> <p>Behavior: - Frees <code>state-&gt;output</code> - Frees <code>state-&gt;path</code> - Frees <code>state-&gt;options</code> - Does not free the structure itself (caller's responsibility)</p> <p>Example: <pre><code>struct wallpaper_state *state = malloc(sizeof(struct wallpaper_state));\n// ... fill state ...\n\n// Free allocated strings\nfree_wallpaper_state(state);\n\n// Free structure itself\nfree(state);\n</code></pre></p>"},{"location":"development/api-reference/#logging-api","title":"Logging API","text":"<p>The logging API provides formatted output with color-coded severity levels.</p>"},{"location":"development/api-reference/#functions","title":"Functions","text":""},{"location":"development/api-reference/#cflp_successchar-msg","title":"<code>cflp_success(char *msg, ...)</code>","text":"<p>Log success message in green.</p> <p>Parameters: - <code>msg</code> - Format string (printf-style) - <code>...</code> - Variable arguments</p> <p>Color: Green (<code>\\033[0;32m</code>)</p> <p>Example: <pre><code>#include \"cflogprinter.h\"\n\ncflp_success(\"State saved to %s\", state_path);\n// Output (green): \u2713 State saved to /home/user/.local/state/gslapper/state.txt\n</code></pre></p>"},{"location":"development/api-reference/#cflp_errorchar-msg","title":"<code>cflp_error(char *msg, ...)</code>","text":"<p>Log error message in red.</p> <p>Parameters: - <code>msg</code> - Format string (printf-style) - <code>...</code> - Variable arguments</p> <p>Color: Red (<code>\\033[1;31m</code>, bold)</p> <p>Example: <pre><code>cflp_error(\"Failed to open file: %s\", path);\n// Output (red bold): \u2717 Failed to open file: /path/to/file.txt\n</code></pre></p>"},{"location":"development/api-reference/#cflp_warningchar-msg","title":"<code>cflp_warning(char *msg, ...)</code>","text":"<p>Log warning message in yellow.</p> <p>Parameters: - <code>msg</code> - Format string (printf-style) - <code>...</code> - Variable arguments</p> <p>Color: Yellow (<code>\\033[0;33m</code>)</p> <p>Example: <pre><code>cflp_warning(\"Video codec not found, falling back to software decoding\");\n// Output (yellow): \u26a0 Video codec not found, falling back to software decoding\n</code></pre></p>"},{"location":"development/api-reference/#cflp_infochar-msg","title":"<code>cflp_info(char *msg, ...)</code>","text":"<p>Log informational message (no color by default).</p> <p>Parameters: - <code>msg</code> - Format string (printf-style) - <code>...</code> - Variable arguments</p> <p>Color: None (default terminal color)</p> <p>Example: <pre><code>if (VERBOSE) {\n    cflp_info(\"Initializing GStreamer pipeline...\");\n}\n// Output (if VERBOSE): \u2139 Initializing GStreamer pipeline...\n</code></pre></p>"},{"location":"development/api-reference/#cflp_customchar-color-char-msg","title":"<code>cflp_custom(char *color, char *msg, ...)</code>","text":"<p>Log message with custom color.</p> <p>Parameters: - <code>color</code> - ANSI color code string - <code>msg</code> - Format string (printf-style) - <code>...</code> - Variable arguments</p> <p>Available Colors: - <code>RED</code>, <code>GREEN</code>, <code>YELLOW</code>, <code>BLUE</code>, <code>MAGENTA</code>, <code>CYAN</code> (from <code>cflogprinter.h</code>) - <code>RESET</code> - Reset to default terminal color</p> <p>Example: <pre><code>cflp_custom(CYAN, \"Loading image: %s\", path);\ncflp_custom(MAGENTA, \"Status: %s\", status);\ncflp_custom(RESET, \"Back to normal color\");\n</code></pre></p>"},{"location":"development/api-reference/#color-constants","title":"Color Constants","text":"<pre><code>#define RED         \"\\033[1;31m\"    // Bold red\n#define GREEN       \"\\033[0;32m\"    // Green\n#define YELLOW      \"\\033[0;33m\"    // Yellow\n#define BLUE        \"\\033[0;34m\"    // Blue\n#define MAGENTA     \"\\033[0;35m\"    // Magenta\n#define CYAN        \"\\033[0;36m\"    // Cyan\n#define RESET       \"\\033[0m\"       // Reset to default\n</code></pre>"},{"location":"development/api-reference/#internal-apis","title":"Internal APIs","text":"<p>This section documents internal functions and structures used by gSlapper's main implementation.</p>"},{"location":"development/api-reference/#wayland-integration","title":"Wayland Integration","text":""},{"location":"development/api-reference/#global-state-structure","title":"Global State Structure","text":"<pre><code>struct wl_state {\n    struct wl_display *display;           // Wayland display connection\n    struct wl_compositor *compositor;     // Compositor interface\n    struct zwlr_layer_shell_v1 *layer_shell; // Layer shell protocol\n    struct wl_list outputs;               // List of display_output structures\n    char *monitor;                       // User-selected output name (or '*')\n    int surface_layer;                    // Layer level (background, bottom, top, overlay)\n};\n</code></pre>"},{"location":"development/api-reference/#display-output-structure","title":"Display Output Structure","text":"<pre><code>struct display_output {\n    uint32_t wl_name;                  // Wayland output name (numeric)\n    struct wl_output *wl_output;         // Output interface\n    char *name;                         // Output name string (e.g., \"DP-1\")\n    char *identifier;                    // Output model/serial string\n\n    struct wl_state *state;              // Parent state reference\n    struct wl_surface *surface;           // Wayland surface\n    struct zwlr_layer_surface_v1 *layer_surface; // Layer surface\n    struct wl_egl_window *egl_window;    // EGL window\n    EGLSurface *egl_surface;             // EGL surface\n\n    uint32_t width, height;             // Output dimensions\n    uint32_t scale;                     // Output scale factor (DPI)\n\n    struct wl_list link;                 // Link in state.outputs list\n\n    struct wl_callback *frame_callback;   // Frame callback\n    bool redraw_needed;                  // Flag for frame request\n};\n</code></pre>"},{"location":"development/api-reference/#gstreamer-pipeline","title":"GStreamer Pipeline","text":""},{"location":"development/api-reference/#global-gstreamer-elements","title":"Global GStreamer Elements","text":"<pre><code>static GstElement *pipeline;             // Main GStreamer pipeline\nstatic GstBus *bus;                   // Pipeline bus for events/messages\nstatic char *allocated_uri;            // URI for current media (for cleanup)\nstatic bool using_waylandsink;        // Whether using waylandsink for direct rendering\n</code></pre>"},{"location":"development/api-reference/#video-texture-management","title":"Video Texture Management","text":"<pre><code>static GLuint video_texture = 0;       // OpenGL texture for video frames\nstatic GLuint shader_program = 0;       // Default shader program\nstatic GLuint transition_shader_program = 0; // Transition effect shader\nstatic GLuint vao = 0, vbo = 0;    // Vertex array/buffer objects\n\n// Smart texture management to reduce reallocations\nstatic struct {\n    GLuint texture;\n    int current_width;\n    int current_height;\n    gboolean initialized;\n} texture_manager = {0};\n\n// Video frame data for thread-safe texture updates\nstatic struct {\n    gboolean has_new_frame;\n    gint width, height;\n    gpointer data;\n    gsize size;\n    gint last_width, last_height;     // Track dimension changes\n} video_frame_data = {0};\n</code></pre>"},{"location":"development/api-reference/#frame-rate-limiting","title":"Frame Rate Limiting","text":"<pre><code>static struct timespec last_render_time = {0};\nstatic long long target_frame_time_ns = 33333333;  // Default ~30 FPS\nstatic int frame_rate_cap = 30;                   // Default 30 FPS\nstatic int frames_skipped = 0;                     // Adaptive skipping\n</code></pre> <p>Purpose: Reduce GPU usage by limiting rendering rate.</p> <p>Default: 30 FPS (adjustable via <code>-r</code> CLI flag)</p>"},{"location":"development/api-reference/#state-management-globals","title":"State Management Globals","text":"<pre><code>static char *state_file_path = NULL;\nstatic bool systemd_mode = false;\nstatic bool save_state_on_exit = true;\nstatic bool restore_flag = false;\nstatic bool save_state_flag = false;\n\nstatic double restore_position = 0.0;\nstatic bool restore_paused = false;\n</code></pre>"},{"location":"development/api-reference/#transition-effects","title":"Transition Effects","text":"<pre><code>typedef enum {\n    TRANSITION_NONE = 0,\n    TRANSITION_FADE\n} transition_type_t;\n\ntypedef struct {\n    transition_type_t type;       // Transition effect type\n    bool active;                 // Currently in transition\n    bool enabled;                // Transitions globally enabled\n    float duration;              // Transition duration in seconds\n    float elapsed;               // Time since transition started\n    float progress;              // 0.0 to 1.0 (0% to 100%)\n\n    GLuint old_texture;          // Previous wallpaper texture\n    GLuint new_texture;          // New wallpaper texture\n    int old_width, old_height;  // Old wallpaper dimensions\n    int new_width, new_height;  // New wallpaper dimensions\n    float old_scale_x, old_scale_y; // Old scaling factors\n    float alpha_old, alpha_new;   // Blend factors\n\n    struct timespec start_time;    // Transition start time\n} transition_state_t;\n</code></pre> <p>Note: Transitions only work between static images, not videos.</p>"},{"location":"development/api-reference/#configuration-management","title":"Configuration Management","text":"<pre><code>static struct {\n    char **pauselist;          // List of app names for auto-pause\n    char **stoplist;           // List of app names for auto-stop\n\n    int argc;                   // Saved argc for restart\n    char **argv_copy;           // Saved argv for restart\n    char *save_info;            // Saved command info\n\n    bool auto_pause;             // Auto-pause when wallpaper hidden\n    bool auto_stop;              // Auto-stop when wallpaper hidden\n\n    int is_paused;              // Current pause state\n    bool frame_ready;            // New frame available flag\n    bool stop_render_loop;        // Flag to stop rendering loop\n} app_state = {0};\n</code></pre>"},{"location":"development/api-reference/#command-line-parsing","title":"Command-Line Parsing","text":""},{"location":"development/api-reference/#supported-options","title":"Supported Options","text":"Short Long Type Description <code>-h</code> <code>--help</code> flag Display help message <code>-v</code> <code>--verbose</code> flag Be more verbose (-vv for higher verbosity) <code>-f</code> <code>--fork</code> flag Fork to background after starting <code>-d</code> <code>--help-output</code> flag Display all available outputs and quit <code>-p</code> <code>--auto-pause</code> flag Auto-pause when wallpaper hidden <code>-s</code> <code>--auto-stop</code> flag Auto-stop when wallpaper hidden <code>-n</code> <code>--slideshow</code> seconds Slideshow mode (TODO: not fully implemented) <code>-l</code> <code>--layer</code> string Shell surface layer (background, bottom, top, overlay) <code>-o</code> <code>--gst-options</code> string GStreamer options (see below) <code>-r</code> <code>--fps-cap</code> int Frame rate cap (30, 60, or 100 FPS) <code>-I</code> <code>--ipc-socket</code> path Enable IPC control via Unix socket <code>--transition-type</code> string Transition effect (none, fade) <code>--transition-duration</code> float Transition duration in seconds (default: 0.5) <code>-S</code> <code>--systemd</code> flag Enable systemd service mode <code>-R</code> <code>--restore</code> flag Restore wallpaper from saved state <code>--save-state</code> flag Save current state and exit <code>--state-file</code> path Use custom state file path <code>--no-save-state</code> flag Disable automatic state saving on exit"},{"location":"development/api-reference/#gstreamer-options-passed-via-o","title":"GStreamer Options (passed via <code>-o</code>)","text":"Option Description Default <code>loop</code> Seamless video looping Off <code>fill</code> Fill screen maintaining aspect ratio (crop excess) Default for images <code>panscan=X</code> Fit inside screen (0.0-1.0 scale factor) 1.0 (full) <code>stretch</code> Fill screen ignoring aspect ratio Off <code>original</code> Display at native resolution Off <code>no-audio</code> Disable audio playback Off"},{"location":"development/api-reference/#helper-programs","title":"Helper Programs","text":""},{"location":"development/api-reference/#holderc","title":"holder.c","text":"<p>Purpose: Gatekeeper process that checks stoplist conditions before main program runs.</p> <p>Behavior: 1. Reads stoplist from <code>~/.config/mpvpaper/stoplist</code> 2. Monitors running applications 3. Allows main program to run only if no stoplist app is active 4. Manages process lifecycle transitions</p> <p>Usage: Automatically invoked by main gSlapper binary (not user-facing).</p>"},{"location":"development/api-reference/#thread-safety","title":"Thread Safety","text":""},{"location":"development/api-reference/#mutexes","title":"Mutexes","text":"Mutex Purpose <code>video_mutex</code> Protects <code>video_frame_data</code> and texture updates <code>state_mutex</code> Protects state file operations IPC queue lock Protects command queue (internal to ipc.c)"},{"location":"development/api-reference/#thread-model","title":"Thread Model","text":"<p>gSlapper uses multi-threading: - Main Thread: Wayland event loop, rendering, IPC command processing - GStreamer Bus Thread: Handles pipeline events (EOM, errors, state changes) - Pause/Stop Monitor Thread: Checks stoplist/pauselist conditions - IPC Server Thread: Accepts client connections and enqueues commands</p>"},{"location":"development/api-reference/#error-handling","title":"Error Handling","text":""},{"location":"development/api-reference/#common-return-values","title":"Common Return Values","text":"Value Meaning <code>0</code> Success <code>-1</code> Failure (check errno) <code>NULL</code> Failure (check logs) <code>false</code> Failure <code>true</code> Success"},{"location":"development/api-reference/#error-logging","title":"Error Logging","text":"<p>All errors are logged via <code>cflp_error()</code> with descriptive messages.</p> <p>Common Error Scenarios: - Wayland connection failed: Check <code>WAYLAND_DISPLAY</code> environment variable - File not found: Check path in state file - GStreamer pipeline error: Check codec support, install <code>gst-plugins-ugly</code> - IPC socket error: Check socket path, permissions</p>"},{"location":"development/api-reference/#building-with-these-apis","title":"Building with these APIs","text":""},{"location":"development/api-reference/#example-custom-wallpaper-manager","title":"Example: Custom Wallpaper Manager","text":"<pre><code>#include \"ipc.h\"\n#include &lt;stdio.h&gt;\n\nint main() {\n    // Start gSlapper with IPC\n    system(\"gslapper -I /tmp/gslapper.sock -o 'loop' DP-1 /path/to/video.mp4 &amp;\");\n    sleep(2);  // Wait for startup\n\n    // Connect to IPC\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    struct sockaddr_un addr;\n    memset(&amp;addr, 0, sizeof(addr));\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, \"/tmp/gslapper.sock\", sizeof(addr.sun_path) - 1);\n\n    if (connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {\n        perror(\"Connect failed\");\n        return 1;\n    }\n\n    // Interactive control\n    char input[256];\n    while (1) {\n        printf(\"&gt; \");\n        fgets(input, sizeof(input), stdin);\n\n        if (strcmp(input, \"pause\\n\") == 0) {\n            write(fd, \"pause\\n\", 6);\n        } else if (strcmp(input, \"resume\\n\") == 0) {\n            write(fd, \"resume\\n\", 7);\n        } else if (strcmp(input, \"quit\\n\") == 0) {\n            write(fd, \"stop\\n\", 5);\n            break;\n        }\n\n        // Read response\n        char response[1024];\n        ssize_t n = read(fd, response, sizeof(response) - 1);\n        if (n &gt; 0) {\n            response[n] = '\\0';\n            printf(\"%s\", response);\n        }\n    }\n\n    close(fd);\n    return 0;\n}\n</code></pre>"},{"location":"development/api-reference/#example-state-based-wallpaper-switcher","title":"Example: State-Based Wallpaper Switcher","text":"<pre><code>#include \"state.h\"\n#include &lt;dirent.h&gt;\n\nvoid switch_wallpaper(const char *new_path) {\n    struct wallpaper_state state;\n    char *state_path = get_state_file_path(\"DP-1\");\n\n    // Load current state\n    if (state_path &amp;&amp; load_state_file(state_path, &amp;state) == 0) {\n        // Update path\n        free(state.path);\n        state.path = strdup(new_path);\n\n        // Save state\n        if (save_state_file(state_path, &amp;state) == 0) {\n            printf(\"State updated: %s\\n\", new_path);\n        }\n    }\n\n    free(state_path);\n}\n</code></pre>"},{"location":"development/api-reference/#see-also","title":"See Also","text":"<ul> <li>Architecture Documentation - Detailed architecture overview</li> <li>Command Line Options - User-facing CLI reference</li> <li>IPC Control Guide - Using IPC from scripts</li> <li>Persistent Wallpapers - State management usage</li> <li>TO_IMPLEMENT.md - Planned features and API additions</li> </ul>"},{"location":"development/architecture/","title":"Architecture","text":"<p>This document provides an overview of gSlapper's internal architecture and design decisions.</p>"},{"location":"development/architecture/#overview","title":"Overview","text":"<p>gSlapper is a high-performance wallpaper manager for Wayland that combines the best of swww and mpvpaper. It uses GStreamer for media playback and EGL/OpenGL for rendering, providing faster performance, better efficiency, and fixes memory leaks on NVIDIA Wayland systems while offering superior multi-monitor support.</p>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#mainc","title":"main.c","text":"<p>The main application file (<code>src/main.c</code>, ~2000 lines) contains:</p> <ul> <li>GStreamer pipeline management - <code>init_gst()</code>, <code>buffer_probe()</code>, <code>bus_callback()</code></li> <li>EGL/OpenGL rendering - <code>init_egl()</code>, <code>render()</code>, <code>create_shader_program()</code></li> <li>Wayland compositor integration - <code>layer_surface_configure()</code>, <code>output_listener()</code></li> <li>Video texture management - Smart allocation with <code>texture_manager</code> struct</li> <li>Seamless looping - Segment-based looping via <code>GST_MESSAGE_SEGMENT_DONE</code></li> <li>Multi-output support - Independent rendering per monitor</li> <li>Thread management - Event handling and process monitoring</li> </ul>"},{"location":"development/architecture/#holderc","title":"holder.c","text":"<p>Process monitoring (<code>src/holder.c</code>, ~420 lines):</p> <ul> <li>Minimal Wayland client that monitors gslapper state</li> <li>Handles stoplist/pauselist functionality</li> <li>Revives main process when conditions are met</li> <li>Acts as a \"gate keeper\" before main application runs</li> </ul>"},{"location":"development/architecture/#ipcch","title":"ipc.c/h","text":"<p>IPC control system (<code>src/ipc.c</code>, <code>inc/ipc.h</code>, ~500 lines):</p> <ul> <li>Unix domain socket server for runtime control</li> <li>Thread-safe command queue with mutex protection</li> <li>Client thread per connection, main thread processes commands</li> <li>Wakeup pipe integrates with main <code>poll()</code> loop</li> <li>Supports pause/resume/query/change/transition commands</li> </ul>"},{"location":"development/architecture/#cflogprinterch","title":"cflogprinter.c/h","text":"<p>Custom colored logging system:</p> <ul> <li>Functions: <code>cflp_info()</code>, <code>cflp_success()</code>, <code>cflp_warning()</code>, <code>cflp_error()</code></li> <li>Provides consistent logging format across the application</li> </ul>"},{"location":"development/architecture/#gladc","title":"glad.c","text":"<p>OpenGL function loader (generated code):</p> <ul> <li>Provides EGL and OpenGL function pointers</li> <li>Enables runtime OpenGL function resolution</li> </ul>"},{"location":"development/architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"development/architecture/#segment-based-looping","title":"Segment-Based Looping","text":"<p>Uses <code>GST_SEEK_FLAG_SEGMENT</code> instead of EOS-based looping:</p> <ul> <li>Eliminates playback gaps between loops</li> <li>Initialized on first <code>GST_STATE_PLAYING</code> transition</li> <li>Handled in <code>bus_callback()</code> (lines 976-1016)</li> </ul>"},{"location":"development/architecture/#smart-texture-management","title":"Smart Texture Management","text":"<p>Reuses texture allocation when dimensions match:</p> <ul> <li>Reduces GPU memory reallocations</li> <li>Prevents memory accumulation during playback</li> <li>Implemented in texture manager (lines 84-336)</li> </ul>"},{"location":"development/architecture/#thread-safe-frame-updates","title":"Thread-Safe Frame Updates","text":"<ul> <li><code>video_mutex</code> protects shared frame data</li> <li><code>buffer_probe()</code> callback copies frame data asynchronously</li> <li>Wakeup pipe triggers rendering from main thread</li> <li>Frame updates (lines 881-945)</li> </ul>"},{"location":"development/architecture/#egl-context-management","title":"EGL Context Management","text":"<p>Creates compatibility context first, falls back to core:</p> <ul> <li>Tries multiple OpenGL versions (3.3, 3.2, 4.x)</li> <li>Required for multi-output rendering</li> <li>Context management (lines 1326-1411)</li> </ul>"},{"location":"development/architecture/#ipc-command-queue","title":"IPC Command Queue","text":"<ul> <li>Thread-safe command queue with mutex protection</li> <li>Wakeup pipe integrates with main <code>poll()</code> loop</li> <li>Client threads handle socket I/O, main thread processes commands</li> <li>Responses sent back to clients via socket</li> </ul>"},{"location":"development/architecture/#gstreamer-pipeline","title":"GStreamer Pipeline","text":""},{"location":"development/architecture/#pipeline-architecture","title":"Pipeline Architecture","text":"<pre><code>playbin \u2192 appsink (RGBA format) \u2192 buffer_probe \u2192 texture_manager \u2192 OpenGL rendering\n</code></pre>"},{"location":"development/architecture/#options-handling","title":"Options Handling","text":"<p>The <code>apply_gst_options()</code> function handles:</p> <ul> <li><code>loop</code> - Enables segment-based seamless looping (videos only)</li> <li><code>no-audio</code>/<code>mute</code> - Disables audio playback (videos only)</li> <li><code>panscan=X</code> - Scales content by factor X (0.0-1.0, default for videos)</li> <li><code>fill</code> - Fill screen maintaining aspect ratio, crop excess (default for images)</li> <li><code>stretch</code> - Fill screen ignoring aspect ratio</li> <li><code>original</code> - Display at actual pixel dimensions (1:1 mapping)</li> <li>Frame rate capping: 30/60/100 FPS options</li> </ul>"},{"location":"development/architecture/#image-support","title":"Image Support","text":"<p>Image pipeline:</p> <pre><code>filesrc \u2192 typefind \u2192 decoder \u2192 videoconvert \u2192 imagefreeze \u2192 appsink (RGBA)\n</code></pre> <ul> <li>Format detection via file extension (case-insensitive)</li> <li>Uses GStreamer <code>imagefreeze</code> element for static display</li> <li>Default scaling mode: <code>fill</code> (crop to fill screen)</li> <li>Transitions: Supports fade transition between images (opt-in)</li> </ul>"},{"location":"development/architecture/#wayland-integration","title":"Wayland Integration","text":""},{"location":"development/architecture/#layer-shell-protocol","title":"Layer Shell Protocol","text":"<ul> <li>Uses <code>wlr-layer-shell-unstable-v1</code> protocol</li> <li>Supports background, bottom, top, overlay layers</li> <li>Handles multi-monitor configurations via <code>wl_output</code></li> </ul>"},{"location":"development/architecture/#surface-management","title":"Surface Management","text":"<ul> <li>One <code>wl_surface</code> + <code>zwlr_layer_surface_v1</code> per output</li> <li>EGL window surface for each output</li> <li>Frame callbacks coordinate rendering with compositor</li> </ul>"},{"location":"development/architecture/#transition-system","title":"Transition System","text":""},{"location":"development/architecture/#architecture_1","title":"Architecture","text":"<p>Transition state structure:</p> <pre><code>typedef struct {\n    transition_type_t type;      // TRANSITION_NONE or TRANSITION_FADE\n    bool active;                 // Currently transitioning?\n    bool enabled;                // Globally enabled?\n    float duration;              // Total duration in seconds\n    float progress;              // Progress 0.0-1.0\n    uint8_t *old_pixels;         // Old image pixels (RGBA)\n    uint8_t *new_pixels;         // New image pixels (RGBA)\n    uint8_t *blend_pixels;       // Blended result for display\n    int width, height;           // Display resolution\n    struct timespec start_time;\n} transition_state_t;\n</code></pre>"},{"location":"development/architecture/#core-functions","title":"Core Functions","text":"<ol> <li><code>start_transition()</code> - Captures current wallpaper, prepares buffers</li> <li><code>activate_transition()</code> - Loads new image and starts blending</li> <li><code>update_transition()</code> - Blends pixels each frame using integer math</li> <li><code>complete_transition()</code> - Cleans up after completion</li> <li><code>cancel_transition()</code> - Cancels ongoing transition</li> </ol>"},{"location":"development/architecture/#blending-algorithm","title":"Blending Algorithm","text":"<p>CPU-based alpha blending for speed:</p> <pre><code>// Integer-based alpha blending\nint step = (int)(progress * 256.0f);\nblend[i] = ((old[i] * (256 - step) + new[i] * step) &gt;&gt; 8);\n</code></pre>"},{"location":"development/architecture/#memory-management","title":"Memory Management","text":""},{"location":"development/architecture/#critical-cleanup-order","title":"Critical Cleanup Order","text":"<p>The <code>exit_cleanup()</code> function follows this order:</p> <ol> <li>Signal threads to stop</li> <li>Cancel all pthread threads</li> <li>Clean up texture manager</li> <li>Graceful GStreamer shutdown (PAUSED \u2192 READY \u2192 NULL)</li> <li>Unref pipeline and bus</li> <li>Destroy EGL contexts</li> <li>Free allocated strings and arrays</li> </ol>"},{"location":"development/architecture/#memory-leak-prevention","title":"Memory Leak Prevention","text":"<ul> <li>Always free GStreamer objects with <code>gst_object_unref()</code></li> <li>Destroy Wayland objects in reverse creation order</li> <li>Use <code>g_free()</code> for GLib allocations, <code>free()</code> for malloc()</li> </ul>"},{"location":"development/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"development/architecture/#frame-rate-management","title":"Frame Rate Management","text":"<ul> <li>Default 30 FPS cap to reduce GPU load (<code>target_frame_time_ns</code>)</li> <li>Adaptive frame skipping under load</li> <li>Smart texture reallocation only when dimensions change</li> </ul>"},{"location":"development/architecture/#gpu-memory-optimization","title":"GPU Memory Optimization","text":"<ul> <li><code>appsink</code> limited to 1 buffer (<code>max-buffers</code>)</li> <li>Texture updates use <code>glTexSubImage2D()</code></li> <li>Frame rate limiting prevents buffer accumulation</li> </ul>"},{"location":"development/architecture/#multi-monitor-efficiency","title":"Multi-Monitor Efficiency","text":"<ul> <li>Single pipeline with multiple rendering surfaces</li> <li>Shared texture across all outputs</li> <li>Independent rendering per monitor</li> </ul>"},{"location":"development/architecture/#nvidia-specific-handling","title":"NVIDIA-Specific Handling","text":"<ul> <li>Forces <code>GL_BACK</code> draw buffer for NVIDIA Pro drivers</li> <li>Swap interval 0 for immediate presentation</li> <li>Compatibility context preferred over core context</li> </ul>"},{"location":"development/architecture/#threading-model","title":"Threading Model","text":""},{"location":"development/architecture/#main-thread","title":"Main Thread","text":"<ul> <li>Wayland event loop</li> <li>IPC command processing</li> <li>Rendering coordination</li> <li>GStreamer bus message handling</li> </ul>"},{"location":"development/architecture/#worker-threads","title":"Worker Threads","text":"<ul> <li>IPC client threads - Handle individual socket connections</li> <li>Pauselist monitor - Monitors pauselist file changes</li> <li>Stoplist monitor - Monitors stoplist file changes</li> </ul>"},{"location":"development/architecture/#thread-communication","title":"Thread Communication","text":"<ul> <li><code>video_mutex</code> - Protects shared video frame data</li> <li><code>ipc_queue_mutex</code> - Protects IPC command queue</li> <li><code>wakeup_pipe</code> - Signals main thread for IPC commands</li> <li>Frame callbacks - Coordinate rendering with compositor</li> </ul>"},{"location":"development/architecture/#file-structure","title":"File Structure","text":"<pre><code>gSlapper/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.c          # Main application (~2000 lines)\n\u2502   \u251c\u2500\u2500 holder.c        # Process monitoring (~420 lines)\n\u2502   \u251c\u2500\u2500 ipc.c           # IPC control system (~500 lines)\n\u2502   \u251c\u2500\u2500 cflogprinter.c  # Logging system\n\u2502   \u2514\u2500\u2500 glad.c          # OpenGL loader\n\u251c\u2500\u2500 inc/\n\u2502   \u251c\u2500\u2500 ipc.h           # IPC interface\n\u2502   \u251c\u2500\u2500 cflogprinter.h  # Logging interface\n\u2502   \u2514\u2500\u2500 glad/           # OpenGL headers\n\u251c\u2500\u2500 proto/\n\u2502   \u2514\u2500\u2500 wlr-layer-shell-unstable-v1.xml  # Wayland protocol\n\u2514\u2500\u2500 docs/               # Documentation\n</code></pre>"},{"location":"development/architecture/#future-improvements","title":"Future Improvements","text":"<ul> <li>GPU-accelerated transitions (shader-based blending)</li> <li>Image preloading and caching</li> <li>Additional transition effects (wipe, center, outer, random)</li> <li>Hardware-accelerated video decoding</li> <li>Better error recovery and resilience</li> </ul>"},{"location":"development/building/","title":"Building from Source","text":"<p>This guide covers building gSlapper from source for development and customization.</p>"},{"location":"development/building/#prerequisites","title":"Prerequisites","text":""},{"location":"development/building/#arch-linux","title":"Arch Linux","text":"<pre><code># Runtime dependencies\nsudo pacman -S gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav\n\n# Build dependencies\nsudo pacman -S meson ninja wayland-protocols\n</code></pre>"},{"location":"development/building/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Runtime dependencies\nsudo apt install gstreamer1.0-tools gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\\n                 gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav\n\n# Build dependencies\nsudo apt install meson ninja-build wayland-protocols libunwind-dev\n</code></pre>"},{"location":"development/building/#fedorarhel","title":"Fedora/RHEL","text":"<pre><code># Runtime dependencies\nsudo dnf install gstreamer1 gstreamer1-plugins-base gstreamer1-plugins-good \\\n                 gstreamer1-plugins-bad gstreamer1-plugins-ugly gstreamer1-libav\n\n# Build dependencies\nsudo dnf install meson ninja-build wayland-protocols-devel\n</code></pre>"},{"location":"development/building/#building","title":"Building","text":""},{"location":"development/building/#standard-build","title":"Standard Build","text":"<pre><code>git clone https://github.com/Nomadcxx/gSlapper.git\ncd gSlapper\nmeson setup build --prefix=/usr/local --buildtype=release\nninja -C build\nsudo ninja -C build install\n</code></pre>"},{"location":"development/building/#debug-build","title":"Debug Build","text":"<p>For development with debug symbols and verbose logging:</p> <pre><code>meson setup build --buildtype=debug\nninja -C build\n./build/gslapper --help\n</code></pre>"},{"location":"development/building/#custom-installation-prefix","title":"Custom Installation Prefix","text":"<pre><code>meson setup build --prefix=/usr\nninja -C build\nsudo ninja -C build install\n</code></pre>"},{"location":"development/building/#build-options","title":"Build Options","text":""},{"location":"development/building/#available-options","title":"Available Options","text":"<p>Check available build options:</p> <pre><code>meson configure build\n</code></pre>"},{"location":"development/building/#common-options","title":"Common Options","text":"<pre><code># Set custom prefix\nmeson setup build --prefix=/opt/gslapper\n\n# Enable/disable features (if available)\nmeson setup build -Dfeature=enabled\n\n# Set build type\nmeson setup build --buildtype=release  # or debug, debugoptimized\n</code></pre>"},{"location":"development/building/#testing-the-build","title":"Testing the Build","text":"<p>After building, test the binary:</p> <pre><code># Check help output\n./build/gslapper --help\n\n# List available outputs\n./build/gslapper -d\n\n# Test with a video\n./build/gslapper -v DP-1 /path/to/video.mp4\n\n# Test with an image\n./build/gslapper -v DP-1 /path/to/image.jpg\n</code></pre>"},{"location":"development/building/#rebuilding","title":"Rebuilding","text":"<p>After making code changes:</p> <pre><code># Quick rebuild\nninja -C build\n\n# Clean rebuild\nrm -rf build\nmeson setup build --prefix=/usr/local --buildtype=release\nninja -C build\n</code></pre>"},{"location":"development/building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/building/#missing-codecs","title":"Missing Codecs","text":"<p>If videos fail to play, ensure codec plugins are installed:</p> <pre><code># Arch Linux\nsudo pacman -S gst-plugins-ugly gst-libav\n\n# Ubuntu/Debian\nsudo apt install gstreamer1.0-plugins-ugly gstreamer1.0-libav\n</code></pre>"},{"location":"development/building/#wayland-protocol-errors","title":"Wayland Protocol Errors","text":"<p>If you see protocol errors, ensure wayland-protocols is installed:</p> <pre><code># Arch Linux\nsudo pacman -S wayland-protocols\n\n# Ubuntu/Debian\nsudo apt install wayland-protocols\n</code></pre>"},{"location":"development/building/#gstreamer-not-found","title":"GStreamer Not Found","text":"<p>If meson can't find GStreamer:</p> <pre><code># Check pkg-config\npkg-config --modversion gstreamer-1.0\n\n# Install development packages\n# Arch Linux\nsudo pacman -S gstreamer gst-plugins-base\n\n# Ubuntu/Debian\nsudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev\n</code></pre>"},{"location":"development/building/#development-workflow","title":"Development Workflow","text":"<ol> <li>Make changes to source files in <code>src/</code></li> <li>Rebuild with <code>ninja -C build</code></li> <li>Test with <code>./build/gslapper</code></li> <li>Debug with <code>-vv</code> flag for verbose output</li> <li>Iterate as needed</li> </ol>"},{"location":"development/building/#package-building","title":"Package Building","text":"<p>For Arch Linux package building:</p> <pre><code># Build package\nmakepkg -si\n\n# Update .SRCINFO after PKGBUILD changes\nmakepkg --printsrcinfo &gt; .SRCINFO\n</code></pre> <p>See PKGBUILD for package configuration.</p>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to gSlapper! This guide will help you get started.</p>"},{"location":"development/contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR_USERNAME/gSlapper.git\ncd gSlapper\n</code></pre></li> <li>Create a branch for your changes:    <pre><code>git checkout -b feature/your-feature-name\n</code></pre></li> </ol>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<p>See Building from Source for setup instructions.</p>"},{"location":"development/contributing/#code-style","title":"Code Style","text":"<ul> <li>C code follows K&amp;R style with 4-space indentation</li> <li>GStreamer objects use <code>g_</code> prefix (GLib naming)</li> <li>Wayland objects use <code>wl_</code> prefix</li> <li>Static functions at file scope</li> <li>Global state in <code>global_state</code> pointer</li> <li>Thread communication via <code>wakeup_pipe</code></li> </ul>"},{"location":"development/contributing/#making-changes","title":"Making Changes","text":""},{"location":"development/contributing/#adding-new-features","title":"Adding New Features","text":"<ol> <li>Plan your changes - Consider architecture and impact</li> <li>Update documentation - Add/update relevant docs</li> <li>Add tests - Create test scripts if applicable</li> <li>Test thoroughly - Test on different compositors and setups</li> </ol>"},{"location":"development/contributing/#adding-new-ipc-commands","title":"Adding New IPC Commands","text":"<ol> <li>Define command handler in <code>src/main.c</code>'s <code>process_ipc_commands()</code> function</li> <li>Parse command arguments from <code>cmd_line</code> string</li> <li>Validate inputs and check state</li> <li>Implement command logic with thread safety in mind</li> <li>Send response via <code>ipc_send_response(client_fd, response)</code></li> <li>Free command with <code>free(cmd-&gt;cmd_line)</code> and <code>free(cmd)</code></li> </ol> <p>See existing commands like <code>set-transition</code> or <code>change</code> for examples.</p>"},{"location":"development/contributing/#adding-new-transition-effects","title":"Adding New Transition Effects","text":"<ol> <li>Add transition type to <code>transition_type_t</code> enum</li> <li>Implement transition function (similar to <code>update_transition()</code>)</li> <li>Update command parser in IPC <code>set-transition</code> handler</li> <li>Add command-line option parsing in <code>parse_command_line()</code></li> <li>Test with automated and visual tests</li> </ol>"},{"location":"development/contributing/#modifying-rendering-pipeline","title":"Modifying Rendering Pipeline","text":"<ol> <li>Locate rendering code in <code>render()</code> function</li> <li>Ensure EGL context is current before OpenGL calls</li> <li>Lock <code>video_mutex</code> when accessing <code>video_frame_data</code> or <code>transition_state</code></li> <li>Update vertex data with <code>update_vertex_data()</code> for scaling changes</li> </ol>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#basic-functionality","title":"Basic Functionality","text":"<pre><code># Test video playback\n./build/gslapper -v DP-1 /path/to/video.mp4\n\n# Test image display\n./build/gslapper -v DP-1 /path/to/image.jpg\n\n# Test with IPC enabled\n./build/gslapper -I /tmp/test.sock -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"development/contributing/#test-scripts","title":"Test Scripts","text":"<p>Run the included test scripts:</p> <pre><code># Video format testing\n./test-all-formats.sh\n\n# Image format testing\n./test-images.sh\n\n# Wallpaper modes testing\n./test-wallpaper-modes.sh\n\n# Transition effects testing\n./test-transitions-comprehensive.sh\n</code></pre>"},{"location":"development/contributing/#ipc-testing","title":"IPC Testing","text":"<pre><code># Start with IPC enabled\n./build/gslapper -I /tmp/test.sock -vv -o \"loop\" DP-1 video.mp4\n\n# From another terminal, test commands\necho \"query\" | nc -U /tmp/test.sock\necho \"pause\" | nc -U /tmp/test.sock\necho \"resume\" | nc -U /tmp/test.sock\n</code></pre>"},{"location":"development/contributing/#commit-guidelines","title":"Commit Guidelines","text":"<ul> <li>Write clear commit messages - Explain what and why</li> <li>Keep commits focused - One logical change per commit</li> <li>Test before committing - Ensure changes work</li> <li>Update documentation - Keep docs in sync with code</li> </ul>"},{"location":"development/contributing/#commit-message-format","title":"Commit Message Format","text":"<pre><code>Short summary (50 chars or less)\n\nMore detailed explanation if needed. Wrap at 72 characters.\nExplain what the change does and why.\n\n- Bullet points for multiple changes\n- Reference issues if applicable\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure your code works - Test on your system</li> <li>Update documentation - Keep docs current</li> <li>Write a clear PR description - Explain changes and motivation</li> <li>Reference issues - Link to related issues if applicable</li> <li>Wait for review - Be responsive to feedback</li> </ol>"},{"location":"development/contributing/#areas-for-contribution","title":"Areas for Contribution","text":"<ul> <li>Bug fixes - Report and fix issues</li> <li>Performance improvements - Optimize rendering or memory usage</li> <li>New features - Add requested functionality</li> <li>Documentation - Improve docs and examples</li> <li>Testing - Add test coverage</li> <li>Code quality - Refactor and improve code</li> </ul>"},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ul> <li>gSlapper version - <code>gslapper --version</code> or git commit</li> <li>System information - OS, compositor, GPU</li> <li>Steps to reproduce - Clear reproduction steps</li> <li>Expected behavior - What should happen</li> <li>Actual behavior - What actually happens</li> <li>Logs - Output with <code>-vv</code> flag if applicable</li> </ul>"},{"location":"development/contributing/#questions","title":"Questions?","text":"<p>Feel free to open an issue for questions or discussions about contributions.</p>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"development/gstreamer-1.26.10-compatibility/","title":"GStreamer 1.26.10 Compatibility Check","text":""},{"location":"development/gstreamer-1.26.10-compatibility/#overview","title":"Overview","text":"<p>GStreamer 1.26.10 was released on December 25, 2025. This document verifies gSlapper's compatibility with this version.</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#gslappers-gstreamer-usage","title":"gSlapper's GStreamer Usage","text":""},{"location":"development/gstreamer-1.26.10-compatibility/#core-dependencies","title":"Core Dependencies","text":"<ul> <li><code>gstreamer-1.0</code> - Core GStreamer library</li> <li><code>gstreamer-video-1.0</code> - Video handling</li> <li><code>gstreamer-gl-1.0</code> - OpenGL/EGL integration</li> </ul>"},{"location":"development/gstreamer-1.26.10-compatibility/#key-apis-used","title":"Key APIs Used","text":"<ol> <li>Pipeline Management:</li> <li><code>gst_element_set_state()</code> - State transitions (NULL, READY, PAUSED, PLAYING)</li> <li><code>gst_element_get_state()</code> - Query current state</li> <li> <p><code>gst_element_seek()</code> / <code>gst_element_seek_simple()</code> - Video position control</p> </li> <li> <p>Playbin:</p> </li> <li><code>playbin3</code> - High-level video playback element</li> <li> <p>Used for automatic codec detection and pipeline construction</p> </li> <li> <p>Appsink:</p> </li> <li>Buffer probe on appsink pad for frame capture</li> <li> <p>RGBA format output for OpenGL rendering</p> </li> <li> <p>Messages:</p> </li> <li><code>GST_MESSAGE_ERROR</code> - Error handling</li> <li><code>GST_MESSAGE_EOS</code> - End of stream</li> <li><code>GST_MESSAGE_SEGMENT_DONE</code> - Seamless looping</li> <li> <p><code>GST_MESSAGE_STATE_CHANGED</code> - State transition monitoring</p> </li> <li> <p>State Management:</p> </li> <li><code>GST_STATE_NULL</code>, <code>GST_STATE_READY</code>, <code>GST_STATE_PAUSED</code>, <code>GST_STATE_PLAYING</code></li> <li>State query and position tracking</li> </ol>"},{"location":"development/gstreamer-1.26.10-compatibility/#plugins-required","title":"Plugins Required","text":"<p>Core plugins (from gst-plugins-base): - <code>playbin3</code> - Video playback - <code>appsink</code> - Frame capture - <code>videoconvert</code> - Format conversion - <code>videoscale</code> - Video scaling</p> <p>Optional plugins (for codec support): - <code>gst-plugins-good</code> - Additional formats - <code>gst-plugins-bad</code> - Extended format support - <code>gst-plugins-ugly</code> - H.264/H.265 codecs - <code>gst-libav</code> - FFmpeg-based codecs</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#gstreamer-12610-changes","title":"GStreamer 1.26.10 Changes","text":""},{"location":"development/gstreamer-1.26.10-compatibility/#release-notes-summary","title":"Release Notes Summary","text":"<p>GStreamer 1.26.10 is a bug-fix release in the stable 1.26 series. According to GStreamer's release policy:</p> <p>\"This release only contains bugfixes and it should be safe to update from 1.26.x.\"</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#key-points","title":"Key Points:","text":"<ol> <li>No Breaking API Changes - Bug-fix releases maintain API compatibility</li> <li>Stability Improvements - Focus on fixing bugs, not adding features</li> <li>Safe to Update - Designed to be drop-in replacement for 1.26.9</li> </ol>"},{"location":"development/gstreamer-1.26.10-compatibility/#potential-impact-areas","title":"Potential Impact Areas","text":"<p>Low Risk (Stable APIs): - \u2705 <code>gst_element_set_state()</code> - Core API, unchanged - \u2705 <code>gst_element_seek()</code> - Stable API - \u2705 <code>GST_MESSAGE_*</code> types - Message system unchanged - \u2705 <code>GST_STATE_*</code> constants - State system unchanged - \u2705 <code>playbin3</code> - High-level element, stable interface</p> <p>Medium Risk (Implementation Details): - \u26a0\ufe0f Buffer probe behavior - May have internal optimizations - \u26a0\ufe0f State transition timing - May have improved synchronization - \u26a0\ufe0f Error handling - May have improved error reporting</p> <p>No Risk: - \u2705 OpenGL/EGL integration - Uses stable <code>gstreamer-gl-1.0</code> API - \u2705 Video format handling - Uses stable <code>gstreamer-video-1.0</code> API</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#compatibility-verification","title":"Compatibility Verification","text":""},{"location":"development/gstreamer-1.26.10-compatibility/#build-test","title":"Build Test","text":"<pre><code># gSlapper builds successfully with GStreamer 1.26.10\nninja -C build\n# Result: \u2705 Builds without errors\n</code></pre>"},{"location":"development/gstreamer-1.26.10-compatibility/#runtime-test","title":"Runtime Test","text":"<pre><code># Basic functionality test\n./build/gslapper --help\n# Result: \u2705 Executes correctly\n\n# State query test\n./build/gslapper -d\n# Result: \u2705 Wayland output detection works\n</code></pre>"},{"location":"development/gstreamer-1.26.10-compatibility/#api-compatibility","title":"API Compatibility","text":"<p>All APIs used by gSlapper are: - \u2705 Part of stable GStreamer 1.0 API - \u2705 Not deprecated in 1.26.x series - \u2705 Backward compatible across 1.26.x releases</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#recommendations","title":"Recommendations","text":""},{"location":"development/gstreamer-1.26.10-compatibility/#safe-to-update","title":"\u2705 Safe to Update","text":"<p>GStreamer 1.26.10 is safe to use with gSlapper because:</p> <ol> <li>Bug-fix release - No API changes</li> <li>Stable APIs used - gSlapper uses well-established APIs</li> <li>Backward compatible - Designed as drop-in replacement</li> <li>Tested compatibility - Builds and runs successfully</li> </ol>"},{"location":"development/gstreamer-1.26.10-compatibility/#potential-benefits","title":"Potential Benefits","text":"<p>Updating to 1.26.10 may provide: - \u2705 Bug fixes in <code>playbin3</code> and <code>decodebin3</code> (mentioned in 1.26.9 notes) - \u2705 Stability improvements in HLS/DASH streaming (not used by gSlapper) - \u2705 General bug fixes and improvements</p>"},{"location":"development/gstreamer-1.26.10-compatibility/#no-action-required","title":"No Action Required","text":"<ul> <li>\u2705 No code changes needed</li> <li>\u2705 No dependency updates required</li> <li>\u2705 No configuration changes needed</li> <li>\u2705 No known breaking changes</li> </ul>"},{"location":"development/gstreamer-1.26.10-compatibility/#monitoring","title":"Monitoring","text":"<p>If issues arise after updating to 1.26.10:</p> <ol> <li> <p>Check GStreamer logs: <pre><code>GST_DEBUG=3 ./build/gslapper -v DP-1 /path/to/video.mp4\n</code></pre></p> </li> <li> <p>Verify plugin availability: <pre><code>gst-inspect-1.0 playbin3\ngst-inspect-1.0 appsink\n</code></pre></p> </li> <li> <p>Test with verbose output: <pre><code>./build/gslapper -vv DP-1 /path/to/video.mp4\n</code></pre></p> </li> </ol>"},{"location":"development/gstreamer-1.26.10-compatibility/#conclusion","title":"Conclusion","text":"<p>gSlapper is fully compatible with GStreamer 1.26.10. The update is safe and recommended as it includes bug fixes and stability improvements without any breaking changes.</p> <p>Status: \u2705 COMPATIBLE - No changes required</p>"},{"location":"development/swww-comparison/","title":"swww vs gSlapper Systemd Service Comparison","text":""},{"location":"development/swww-comparison/#swww-architecture","title":"swww Architecture","text":"<p>swww uses a daemon-client model:</p> <ol> <li><code>swww-daemon</code> - Long-running daemon process</li> <li>Runs continuously, listening on IPC socket</li> <li>Manages wallpapers for all outputs</li> <li>Systemd service just starts: <code>swww-daemon</code></li> <li> <p>No <code>--restore</code> flag needed - daemon handles state internally</p> </li> <li> <p><code>swww</code> (client) - Command-line tool</p> </li> <li>Sends commands to daemon via IPC socket</li> <li>Examples: <code>swww img /path/to/image.jpg</code>, <code>swww query</code></li> </ol> <p>Systemd Service: <pre><code>[Service]\nType=simple\nExecStart=/usr/bin/swww-daemon\n# That's it! The daemon runs forever\n</code></pre></p>"},{"location":"development/swww-comparison/#gslapper-current-architecture","title":"gSlapper Current Architecture","text":"<p>gSlapper uses a one-process-per-wallpaper model (like mpvpaper):</p> <ol> <li><code>gslapper</code> - Single process per wallpaper</li> <li>Each instance manages one output</li> <li>Optional IPC per instance</li> <li> <p>Process exits when wallpaper stops</p> </li> <li> <p>Multi-monitor - Requires multiple instances</p> </li> <li>One <code>gslapper</code> process per monitor</li> <li>Each has its own IPC socket (optional)</li> </ol> <p>Current Systemd Approach (WRONG): - Wrapper script to launch multiple instances \u274c - Complex state file parsing in shell \u274c</p>"},{"location":"development/swww-comparison/#what-we-should-do","title":"What We Should Do","text":""},{"location":"development/swww-comparison/#option-1-match-swww-exactly-daemon-mode","title":"Option 1: Match swww Exactly (Daemon Mode)","text":"<p>Requires significant refactoring: - Create <code>gslapper-daemon</code> that manages all outputs - Single long-running process - IPC for all commands - Internal state management</p> <p>Pros: Matches swww exactly Cons: Major architectural change, breaks existing usage</p>"},{"location":"development/swww-comparison/#option-2-simple-service-per-monitor-current-fix","title":"Option 2: Simple Service Per Monitor (Current + Fix)","text":"<p>Keep current architecture, fix service: - One service instance per monitor (like systemd templates) - Service file: <code>gslapper@.service</code> (template) - Each instance: <code>gslapper --systemd --restore DP-1 /path/to/wallpaper</code> - State restoration built into gslapper</p> <p>Pros: Minimal changes, works with current architecture Cons: Multiple services for multiple monitors</p>"},{"location":"development/swww-comparison/#option-3-single-service-with-output-simplest","title":"Option 3: Single Service with '*' Output (Simplest)","text":"<p>Use gslapper's existing '*' feature: - One service that restores to all monitors - Service: <code>gslapper --systemd --restore '*' /path/to/wallpaper</code> - State file: <code>state.txt</code> (default, no output name) - Works if user wants same wallpaper on all monitors</p> <p>Pros: Simplest, no wrapper needed Cons: Only works for same wallpaper on all monitors</p>"},{"location":"development/swww-comparison/#recommendation-option-2-documentation","title":"Recommendation: Option 2 + Documentation","text":"<ol> <li>Remove wrapper script - Not needed, not how swww works</li> <li>Provide example service file - Show users how to set it up</li> <li>Document multi-monitor setup - Explain systemd template services</li> <li>Keep state restoration - Built into gslapper, works automatically</li> </ol> <p>Example Service File (per monitor): <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service for %i\nAfter=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore %i\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\n[Install]\nWantedBy=default.target\n</code></pre></p> <p>Usage: <pre><code># Enable for DP-1\nsystemctl --user enable gslapper@DP-1.service\n\n# Enable for DP-3  \nsystemctl --user enable gslapper@DP-3.service\n</code></pre></p> <p>This matches swww's simplicity - just a service file, no wrapper scripts.</p>"},{"location":"development/swww-restore-analysis/","title":"How swww Handles Wallpaper Restoration After Reboot","text":""},{"location":"development/swww-restore-analysis/#key-finding-swww-uses-a-cache-system","title":"Key Finding: swww Uses a Cache System","text":"<p>Based on the swww source code and documentation, here's how swww handles restoration:</p>"},{"location":"development/swww-restore-analysis/#1-built-in-cache-system","title":"1. Built-in Cache System","text":"<p>swww-daemon has a cache system that stores the last displayed image for each output:</p> <ul> <li>Cache location: Likely in <code>~/.cache/swww/</code> or similar</li> <li>Automatic restoration: When daemon starts, it automatically loads cached images</li> <li>Per-output cache: Each monitor has its own cached wallpaper</li> </ul> <p>From swww-daemon.1.scd: <pre><code>*--no-cache*\n    Don't search the cache for the last wallpaper for each output.\n    Useful if you always want to select which image 'swww' loads manually using\n    'swww img'\n</code></pre></p> <p>This means: - By default: swww-daemon automatically restores cached wallpapers on startup - With --no-cache: Daemon starts without restoring (blank/black screen)</p>"},{"location":"development/swww-restore-analysis/#2-swww-restore-command","title":"2. swww-restore Command","text":"<p>swww provides a <code>swww restore</code> command that explicitly restores cached wallpapers:</p> <p>From swww-restore.1.scd: <pre><code>Restores the last displayed image on the specified outputs.\n\nThis can be used to split initialization (with *swww init --no-daemon*) and\ncache loading into different steps, in order to avoid race condition traps.\n\nYou can also use this command to restore the last displayed image when\nreconnecting a monitor.\n</code></pre></p> <p>Usage: <pre><code>swww restore                    # Restore all outputs\nswww restore -o DP-1,DP-3      # Restore specific outputs\nswww restore -n namespace       # Restore specific namespace\n</code></pre></p>"},{"location":"development/swww-restore-analysis/#3-common-restoration-methods","title":"3. Common Restoration Methods","text":""},{"location":"development/swww-restore-analysis/#method-1-automatic-default-behavior","title":"Method 1: Automatic (Default Behavior)","text":"<pre><code># Just start the daemon - it automatically restores cached wallpapers\nswww-daemon\n</code></pre> <p>How it works: - Daemon reads cache files on startup - Automatically displays last wallpaper for each output - No manual intervention needed</p>"},{"location":"development/swww-restore-analysis/#method-2-systemd-service-most-common","title":"Method 2: Systemd Service (Most Common)","text":"<pre><code>[Service]\nExecStart=/usr/bin/swww-daemon\n</code></pre> <p>What happens: 1. Systemd starts <code>swww-daemon</code> on login 2. Daemon automatically reads cache and restores wallpapers 3. Wallpapers appear automatically - no <code>swww restore</code> needed</p>"},{"location":"development/swww-restore-analysis/#method-3-manual-restore-command","title":"Method 3: Manual Restore Command","text":"<pre><code># Start daemon without cache\nswww-daemon --no-cache\n\n# Later, manually restore\nswww restore\n</code></pre> <p>Use case: When you want to control when restoration happens</p>"},{"location":"development/swww-restore-analysis/#method-4-shell-script-in-startup","title":"Method 4: Shell Script in Startup","text":"<pre><code># In ~/.bashrc or ~/.zshrc\nswww-daemon &amp;\nswww restore  # Explicit restore (optional - daemon does it automatically)\n</code></pre>"},{"location":"development/swww-restore-analysis/#4-cache-vs-state-files","title":"4. Cache vs State Files","text":"<p>swww approach: - Cache files - Store last displayed image path per output - In-memory state - Daemon keeps state while running - No explicit state files - Just cache for restoration</p> <p>gSlapper approach (current): - State files - Store wallpaper path, options, position, pause state - Explicit restoration - <code>--restore</code> flag loads state - More detailed - Includes video position, options, etc.</p>"},{"location":"development/swww-restore-analysis/#5-why-swww-doesnt-need-systemd-service","title":"5. Why swww Doesn't Need Systemd Service","text":"<p>swww-daemon: - Long-running process - Stays alive indefinitely - Automatic cache restoration - Restores on startup by default - Manual startup works - Users can just run <code>swww-daemon &amp;</code> in shell config - Systemd is optional - Convenience, not requirement</p> <p>Common swww setup patterns:</p> <p>Pattern A: Systemd Service (Recommended) <pre><code>[Service]\nExecStart=/usr/bin/swww-daemon\n</code></pre> - Automatic startup on login - Automatic cache restoration - Process management</p> <p>Pattern B: Shell Script <pre><code># ~/.bashrc or ~/.zshrc\nswww-daemon &amp;\n</code></pre> - Manual startup - Still gets automatic cache restoration - Simpler, no systemd knowledge needed</p> <p>Pattern C: Explicit Restore <pre><code>swww-daemon --no-cache &amp;\nswww restore  # Explicit restore when ready\n</code></pre> - Control over when restoration happens - Useful for race condition avoidance</p>"},{"location":"development/swww-restore-analysis/#6-key-differences-swww-vs-gslapper","title":"6. Key Differences: swww vs gSlapper","text":"Feature swww gSlapper Architecture Daemon (long-running) One-shot process Restoration Automatic cache on startup Explicit <code>--restore</code> flag State Storage Cache files (image paths) State files (path, options, position) After Reboot Daemon auto-restores cache Must restart with <code>--restore</code> Systemd Need Optional (convenience) Required (for auto-restore) Manual Startup Works fine (<code>swww-daemon &amp;</code>) Works but no auto-restore"},{"location":"development/swww-restore-analysis/#7-why-gslapper-needs-systemd-more-than-swww","title":"7. Why gSlapper Needs Systemd More Than swww","text":"<p>swww: - Daemon stays alive - can be started manually - Automatic cache restoration - works without systemd - Systemd is just for convenience (auto-start, process management)</p> <p>gSlapper: - Process exits when done - needs restart after reboot - No automatic restoration - requires <code>--restore</code> flag - Systemd is essential - Without it, users must manually run <code>gslapper --restore</code> after every login</p>"},{"location":"development/swww-restore-analysis/#8-recommendation-for-gslapper","title":"8. Recommendation for gSlapper","text":"<p>We should: 1. \u2705 Keep systemd service - Essential for automatic restoration 2. \u2705 Keep state files - More detailed than swww's cache (video position, etc.) 3. \u2705 Keep <code>--restore</code> flag - Explicit restoration (like <code>swww restore</code>) 4. \u2705 Document manual alternative - Show shell script approach for non-systemd users</p> <p>We could add (future enhancement): - Automatic restoration on startup (like swww's cache) - But this conflicts with our architecture (one-shot process)</p> <p>Current approach is correct: - Systemd service provides automatic restoration - Matches user expectations (wallpaper on login) - More powerful than swww (video position, options, etc.)</p>"},{"location":"development/systemd-analysis/","title":"Systemd Service Analysis: Why Do We Need It?","text":""},{"location":"development/systemd-analysis/#what-does-the-systemd-service-actually-do","title":"What Does the Systemd Service Actually Do?","text":""},{"location":"development/systemd-analysis/#1-automatic-startup-on-login","title":"1. Automatic Startup on Login","text":"<p><pre><code>After=graphical-session.target\nWants=graphical-session.target\n</code></pre> - Starts gSlapper automatically when graphical session is ready - No need to manually run <code>gslapper</code> after each login/reboot</p>"},{"location":"development/systemd-analysis/#2-environment-variable-management","title":"2. Environment Variable Management","text":"<p><pre><code>EnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n</code></pre> - Provides <code>WAYLAND_DISPLAY</code> and <code>XDG_RUNTIME_DIR</code> automatically - Ensures Wayland connection works in systemd context - Without this, gSlapper can't connect to Wayland compositor</p>"},{"location":"development/systemd-analysis/#3-automatic-restart-on-failure","title":"3. Automatic Restart on Failure","text":"<p><pre><code>Restart=on-failure\nRestartSec=5\n</code></pre> - If gSlapper crashes or exits unexpectedly, systemd restarts it - Provides resilience - wallpaper keeps running</p>"},{"location":"development/systemd-analysis/#4-state-restoration","title":"4. State Restoration","text":"<p><pre><code>ExecStart=/usr/bin/gslapper --systemd --restore '*'\n</code></pre> - <code>--restore</code> flag loads saved state from <code>~/.local/state/gslapper/</code> - Resumes wallpaper at last position (videos) or shows last image - Without this, you'd need to manually set wallpaper after each boot</p>"},{"location":"development/systemd-analysis/#5-process-lifecycle-management","title":"5. Process Lifecycle Management","text":"<ul> <li><code>systemctl start/stop/restart</code> - Control wallpaper service</li> <li><code>systemctl reload</code> - Saves state and restarts (SIGHUP)</li> <li><code>journalctl</code> - View logs</li> <li>Integration with system shutdown/reboot</li> </ul>"},{"location":"development/systemd-analysis/#6-systemd-notifications-systemd-flag","title":"6. Systemd Notifications (--systemd flag)","text":"<p><pre><code>#ifdef HAVE_SYSTEMD\n    if (systemd_mode) {\n        sd_notify(0, \"READY=1\");\n    }\n#endif\n</code></pre> - Tells systemd when gSlapper is ready - Allows <code>Type=notify</code> for better startup coordination - Systemd knows when wallpaper is actually displayed (not just process started)</p>"},{"location":"development/systemd-analysis/#why-swww-doesnt-need-systemd-service","title":"Why swww Doesn't Need Systemd Service","text":"<p>swww-daemon architecture: - Long-running daemon - Process stays alive indefinitely - Manual startup - Users run <code>swww-daemon &amp;</code> in shell config or manually - Persistent - Once started, it runs until killed - No state restoration needed - Daemon maintains state in memory</p> <p>Why swww users might still use systemd: - Convenience - automatic startup - Process management - restart on failure - But it's optional - daemon works fine without it</p>"},{"location":"development/systemd-analysis/#why-gslapper-benefits-from-systemd-service","title":"Why gSlapper Benefits from Systemd Service","text":"<p>gSlapper architecture: - One process per wallpaper - Process exits when wallpaper stops - Not a daemon - Designed to exit when done (like mpvpaper) - State-based - Relies on saved state files for restoration - Needs restart - Must be restarted after reboot to restore wallpaper</p> <p>Without systemd service: <pre><code># User must manually do this after every login:\ngslapper --restore DP-1\n# or\ngslapper -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre></p> <p>With systemd service: - Automatic - wallpaper restores on login - No manual intervention needed - Works seamlessly with state restoration</p>"},{"location":"development/systemd-analysis/#can-we-just-run-gslapper-restore-without-systemd","title":"Can We Just Run <code>gslapper --restore</code> Without Systemd?","text":"<p>Yes, technically: <pre><code># In ~/.bashrc or ~/.zshrc:\ngslapper --restore DP-1 &amp;\n</code></pre></p> <p>But you lose: 1. \u274c Automatic restart on failure 2. \u274c Proper environment variable management 3. \u274c Process lifecycle management 4. \u274c Integration with system shutdown 5. \u274c Logging via journalctl 6. \u274c Coordination with graphical session startup 7. \u274c Resource limits and security settings</p> <p>Advantages of shell script approach: 1. \u2705 Simpler - no systemd knowledge needed 2. \u2705 Works on systems without systemd 3. \u2705 More control over startup timing</p> <p>Advantages of systemd service: 1. \u2705 Automatic startup on login 2. \u2705 Automatic restart on failure 3. \u2705 Proper environment management 4. \u2705 Process lifecycle management 5. \u2705 Better integration with system 6. \u2705 Logging and monitoring 7. \u2705 Resource limits and security</p>"},{"location":"development/systemd-analysis/#comparison-with-vs-without-systemd","title":"Comparison: With vs Without Systemd","text":""},{"location":"development/systemd-analysis/#without-systemd-manualshell-script","title":"Without Systemd (Manual/Shell Script)","text":"<pre><code># User must:\n1. Create environment file manually\n2. Run gslapper in shell config or manually\n3. Handle failures manually\n4. No automatic restart\n5. No process management\n</code></pre>"},{"location":"development/systemd-analysis/#with-systemd-service","title":"With Systemd Service","text":"<pre><code># User:\n1. Enable service once: systemctl --user enable gslapper.service\n2. Done - automatic on every login\n3. Automatic restart on failure\n4. Full process management\n5. Integrated with system\n</code></pre>"},{"location":"development/systemd-analysis/#what-systemd-flag-actually-does","title":"What --systemd Flag Actually Does","text":"<p>The <code>--systemd</code> flag enables systemd-specific features:</p> <ol> <li>Systemd notifications - <code>sd_notify(READY=1)</code> when wallpaper is ready</li> <li>Proper exit handling - Notifies systemd when stopping</li> <li>Signal handling - SIGHUP for reload (saves state, restarts)</li> <li>Logging context - Better integration with journalctl</li> </ol> <p>Without --systemd flag: - gSlapper still works - But systemd doesn't know when it's \"ready\" - <code>Type=notify</code> won't work properly - Less integration with systemd lifecycle</p> <p>With --systemd flag: - Full systemd integration - Proper readiness notification - Better process management</p>"},{"location":"development/systemd-analysis/#recommendation","title":"Recommendation","text":"<p>We SHOULD provide a default systemd service because:</p> <ol> <li>gSlapper is not a daemon - Unlike swww-daemon, it exits when done</li> <li>State restoration requires restart - Need to restart after reboot</li> <li>Better user experience - Automatic wallpaper on login</li> <li>Process management - Restart on failure, proper lifecycle</li> <li>Environment management - Wayland variables handled correctly</li> <li>Standard practice - Most Wayland wallpaper tools use systemd</li> </ol> <p>But we should: - Make it easy to customize (template service, clear docs) - Provide instructions for manual setup (shell script alternative) - Explain advantages/disadvantages clearly - Allow users to disable if they prefer manual control</p>"},{"location":"development/systemd-analysis/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Default service - Install and enable by default (post-install hook)</li> <li>Template service - Provide <code>gslapper@.service</code> for per-monitor</li> <li>Clear documentation - Explain what it does and how to customize</li> <li>Comments in service file - Inline instructions for customization</li> <li>Alternative docs - Show shell script approach for non-systemd users</li> </ol>"},{"location":"development/systemd-service/","title":"Systemd Service (Development Documentation)","text":""},{"location":"development/systemd-service/#overview","title":"Overview","text":"<p>gSlapper includes systemd service integration for automatic wallpaper restoration on login. This is optional - gSlapper works perfectly fine without systemd.</p>"},{"location":"development/systemd-service/#implementation-details","title":"Implementation Details","text":""},{"location":"development/systemd-service/#architecture","title":"Architecture","text":"<p>Two-Component Design: 1. Main Program (<code>gslapper</code> binary) - Runs wallpaper display 2. Helper Process (<code>gslapper-holder</code>) - Gatekeeper for stoplist checking</p> <p>Why Helper Process? - Separates stoplist monitoring from main event loop - Allows graceful lifecycle transitions - Manages process restarts (like mpvpaper's approach)</p>"},{"location":"development/systemd-service/#service-modes","title":"Service Modes","text":""},{"location":"development/systemd-service/#user-service-mode-systemd","title":"User Service Mode (<code>--systemd</code>)","text":"<p>Behavior: - Sends <code>sd_notify(READY=1)</code> when wallpaper is displayed - Saves state on <code>SIGHUP</code> (reload signal) - Exits cleanly on <code>SIGTERM</code> (systemd shutdown)</p> <p>Activation: <pre><code>#ifdef HAVE_SYSTEMD\n#include &lt;systemd/sd-daemon.h&gt;\n\n// Notify systemd when ready\nsd_notify(0, \"READY=1\\nSTATUS=Wallpapers loaded and playing\");\n\n// Notify systemd on shutdown\nsd_notify(0, \"STOPPING=1\\nSTATUS=Shutting down\");\n#endif\n</code></pre></p>"},{"location":"development/systemd-service/#manual-mode-default","title":"Manual Mode (default)","text":"<p>Behavior: - Runs until <code>SIGINT</code> (Ctrl+C) or <code>SIGTERM</code> - Saves state on exit (if not disabled with <code>--no-save-state</code>) - No systemd notifications</p>"},{"location":"development/systemd-service/#state-management-in-systemd-service","title":"State Management in Systemd Service","text":""},{"location":"development/systemd-service/#state-saving-triggers","title":"State Saving Triggers","text":"<ol> <li>Automatic on Exit: When service stops (SIGTERM, SIGHUP)</li> <li>Explicit Save: Via IPC <code>save-state</code> command or <code>--save-state</code> flag</li> <li>SIGHUP Reload: Service reload triggers state save + restart</li> </ol>"},{"location":"development/systemd-service/#state-file-format","title":"State File Format","text":"<p>Location: <code>~/.local/state/gslapper/state-&lt;output&gt;.txt</code></p> <p>Format (Simple key=value, not JSON): <pre><code>version=1\noutput=DP-1\npath=/home/user/Videos/wallpaper.mp4\nis_image=false\noptions=loop panscan=0.8\nposition=123.45\npaused=0\n</code></pre></p>"},{"location":"development/systemd-service/#state-file-operations","title":"State File Operations","text":"<pre><code>// From state.c\nchar *get_state_file_path(const char *output_name);\nint save_state_file(const char *path, const struct wallpaper_state *state);\nint load_state_file(const char *path, struct wallpaper_state *state);\nvoid free_wallpaper_state(struct wallpaper_state *state);\n</code></pre> <p>Safety Features: - Atomic writes: Write to <code>.tmp</code> file, then rename - File locking: <code>flock()</code> prevents concurrent writes - Permissions: State files set to <code>0600</code> (user-only) - Backups: Automatic backup before overwriting</p>"},{"location":"development/systemd-service/#service-file-configuration","title":"Service File Configuration","text":""},{"location":"development/systemd-service/#single-service-all-monitors","title":"Single Service (All Monitors)","text":"<p>File: <code>/usr/lib/systemd/user/gslapper.service</code></p> <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service\nDocumentation=https://nomadcxx.github.io/gSlapper/\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore '*'\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\nTimeoutStopSec=30\n\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\nMemoryMax=512M\nCPUQuota=50%\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=default.target\n</code></pre> <p>Key Directives: - <code>Type=notify</code> - Waits for <code>sd_notify(READY=1)</code> before considering service started - <code>ExecStart</code> - Uses <code>--systemd --restore</code> flags - <code>ExecReload</code> - Sends <code>SIGHUP</code> for state save + restart - <code>EnvironmentFile</code> - Loads <code>WAYLAND_DISPLAY</code> from user config - <code>Environment=XDG_RUNTIME_DIR=%t</code> - Sets Wayland runtime directory - <code>MemoryMax</code>, <code>CPUQuota</code> - Resource limits for safety</p>"},{"location":"development/systemd-service/#per-monitor-template","title":"Per-Monitor Template","text":"<p>File: <code>/usr/lib/systemd/user/gslapper@.service</code></p> <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service for %i\nDocumentation=https://nomadcxx.github.io/gSlapper/\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore %i\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\nTimeoutStopSec=30\n\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\nMemoryMax=512M\nCPUQuota=50%\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=default.target\n</code></pre> <p>Usage: <pre><code># Enable per monitor\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-2.service\n\n# Each instance has separate state file:\n# ~/.local/state/gslapper/state-DP-1.txt\n# ~/.local/state/gslapper/state-DP-2.txt\n</code></pre></p>"},{"location":"development/systemd-service/#build-system-integration","title":"Build System Integration","text":""},{"location":"development/systemd-service/#optional-systemd-dependency","title":"Optional systemd Dependency","text":"<p>meson.build: <pre><code># Optional systemd support\nsystemd_dep = dependency('libsystemd', required: false)\nif systemd_dep.found()\n  add_project_arguments('-DHAVE_SYSTEMD', language: 'c')\n  message('Systemd support enabled')\nelse\n  message('Systemd support disabled (libsystemd not found)')\nendif\n</code></pre></p> <p>Compilation Flags: - <code>HAVE_SYSTEMD</code> - Defined when libsystemd is found - Code wraps systemd calls in <code>#ifdef HAVE_SYSTEMD</code></p>"},{"location":"development/systemd-service/#service-file-installation","title":"Service File Installation","text":"<p>PKGBUILD: <pre><code>package() {\n    # ... existing install commands ...\n\n    # Install systemd user service files\n    install -Dm644 gslapper.service \\\n        \"${pkgdir}/usr/lib/systemd/user/gslapper.service\"\n    install -Dm644 gslapper@.service \\\n        \"${pkgdir}/usr/lib/systemd/user/gslapper@.service\"\n}\n</code></pre></p>"},{"location":"development/systemd-service/#environment-variables","title":"Environment Variables","text":""},{"location":"development/systemd-service/#required-environment","title":"Required Environment","text":"<p><code>WAYLAND_DISPLAY</code> (Required): - Wayland display socket (e.g., <code>wayland-0</code>, <code>wayland-1</code>) - Must be set for gSlapper to connect to compositor</p> <p>Configuration: <pre><code># Create environment file\nmkdir -p ~/.config/gslapper\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n</code></pre></p>"},{"location":"development/systemd-service/#optional-environment","title":"Optional Environment","text":"<p><code>XDG_RUNTIME_DIR</code> (Automatically set by systemd): - User runtime directory (e.g., <code>/run/user/1000</code>) - Used for Wayland socket access - Set automatically by systemd service (<code>Environment=XDG_RUNTIME_DIR=%t</code>)</p> <p><code>XDG_STATE_HOME</code> (Optional): - Override default state directory - If set: <code>$XDG_STATE_HOME/gslapper/</code> - If not set: <code>$HOME/.local/state/gslapper/</code></p>"},{"location":"development/systemd-service/#service-lifecycle","title":"Service Lifecycle","text":""},{"location":"development/systemd-service/#startup-sequence","title":"Startup Sequence","text":"<ol> <li>Service Start (systemd)</li> <li>Load Environment - Read <code>~/.config/gslapper/environment</code></li> <li>Load State - Read from <code>~/.local/state/gslapper/state-*.txt</code></li> <li>Initialize Wayland - Connect to compositor</li> <li>Initialize GStreamer - Set up pipeline for video/image</li> <li>Display Wallpaper - Render to layer surface</li> <li>Notify Ready - <code>sd_notify(READY=1)</code></li> <li>Service Active (systemd considers service started)</li> </ol>"},{"location":"development/systemd-service/#reload-sequence-sighup","title":"Reload Sequence (SIGHUP)","text":"<ol> <li>Receive Signal - Systemd sends <code>SIGHUP</code></li> <li>Save Current State - Write position, pause state, options</li> <li>Stop GStreamer - Clean shutdown of pipeline</li> <li>Reload State - Load saved state from file</li> <li>Restart Pipeline - Initialize GStreamer with saved config</li> <li>Resume Playback - Continue from saved position</li> <li>Service Active (systemd continues service)</li> </ol>"},{"location":"development/systemd-service/#shutdown-sequence-sigterm","title":"Shutdown Sequence (SIGTERM)","text":"<ol> <li>Receive Signal - Systemd sends <code>SIGTERM</code></li> <li>Notify Stopping - <code>sd_notify(STOPPING=1)</code></li> <li>Save Current State - Write final state</li> <li>Stop GStreamer - Clean shutdown</li> <li>Cleanup Wayland - Destroy surfaces, close display</li> <li>Exit - Process terminates</li> <li>Service Stopped (systemd marks service as stopped)</li> </ol>"},{"location":"development/systemd-service/#multi-service-deployment","title":"Multi-Service Deployment","text":""},{"location":"development/systemd-service/#single-service-same-wallpaper-all-monitors","title":"Single Service (Same Wallpaper All Monitors)","text":"<p>When to use: - Same wallpaper on all monitors - Simplified setup - Single state file</p> <p>Configuration: <pre><code># Enable single service\nsystemctl --user enable --now gslapper.service\n\n# State file:\n# ~/.local/state/gslapper/state.txt (for '*' output)\n</code></pre></p>"},{"location":"development/systemd-service/#multiple-services-different-wallpaper-per-monitor","title":"Multiple Services (Different Wallpaper Per Monitor)","text":"<p>When to use: - Different wallpapers on each monitor - Independent control per monitor - Per-monitor state management</p> <p>Configuration: <pre><code># Disable single service if running\nsystemctl --user disable gslapper.service\n\n# Enable per-monitor services\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-2.service\nsystemctl --user enable --now gslapper@DP-3.service\n\n# Each has its own state file:\n# ~/.local/state/gslapper/state-DP-1.txt\n# ~/.local/state/gslapper/state-DP-2.txt\n# ~/.local/state/gslapper/state-DP-3.txt\n</code></pre></p> <p>State Files: - Each instance reads/writes its own state file - No conflicts between instances - Independent video positions per monitor</p>"},{"location":"development/systemd-service/#troubleshooting-development","title":"Troubleshooting (Development)","text":""},{"location":"development/systemd-service/#service-fails-to-start","title":"Service Fails to Start","text":"<p>Check logs: <pre><code>journalctl --user -u gslapper.service -n 50\n</code></pre></p> <p>Common issues: 1. Missing <code>WAYLAND_DISPLAY</code>:    <pre><code>Error: Unable to connect to compositor\n</code></pre> Fix: Verify <code>~/.config/gslapper/environment</code> contains correct value</p> <ol> <li> <p>No state file (when using <code>--restore</code>):    <pre><code>Warning: State file not found, starting fresh\n</code></pre> Fix: Not an error, service will start with no wallpaper</p> </li> <li> <p>File not found (path in state file):    <pre><code>Error: File does not exist: /path/to/wallpaper.mp4\n</code></pre> Fix: Update wallpaper path or fix state file</p> </li> </ol>"},{"location":"development/systemd-service/#service-starts-but-no-wallpaper","title":"Service Starts But No Wallpaper","text":"<p>Debug steps: <pre><code># Check service status\nsystemctl --user status gslapper.service\n\n# View full logs\njournalctl --user -u gslapper.service -f\n\n# Check state file\ncat ~/.local/state/gslapper/state-*.txt\n\n# Verify file exists\ntest -f /path/to/wallpaper.mp4 &amp;&amp; echo \"OK\" || echo \"Missing\"\n</code></pre></p>"},{"location":"development/systemd-service/#state-not-persisting","title":"State Not Persisting","text":"<p>Check: <pre><code># Verify state directory exists and is writable\nls -la ~/.local/state/gslapper/\n\n# Check state file permissions\nstat ~/.local/state/gslapper/state-*.txt\n\n# Manual test\ngslapper --save-state\n# Should save to state file\n</code></pre></p>"},{"location":"development/systemd-service/#systemd-support-disabled","title":"systemd Support Disabled","text":"<p>If building without libsystemd: <pre><code>Systemd support disabled (libsystemd not found)\n</code></pre></p> <p>Result: - <code>--systemd</code> flag still works but no <code>sd_notify()</code> calls - Service will still work but <code>Type=notify</code> won't wait for READY - Consider using <code>Type=simple</code> instead</p>"},{"location":"development/systemd-service/#comparison-with-swww","title":"Comparison with swww","text":""},{"location":"development/systemd-service/#swww-daemon-architecture","title":"swww-daemon Architecture","text":"<p>Single Process: - <code>swww-daemon</code> runs continuously - Manages all outputs in one process - Automatic cache restoration on startup - No explicit state file (uses shared memory)</p> <p>Service File: <pre><code>[Service]\nType=simple\nExecStart=/usr/bin/swww-daemon\nRestart=on-failure\n</code></pre></p>"},{"location":"development/systemd-service/#gslapper-architecture","title":"gSlapper Architecture","text":"<p>One Process Per Wallpaper (or One Process for All): - Each service instance manages one output - Explicit state file persistence - State restoration via <code>--restore</code> flag - More detailed state (video position, pause state, options)</p> <p>Service File: <pre><code>[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore &lt;output&gt;\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\n</code></pre></p>"},{"location":"development/systemd-service/#key-differences","title":"Key Differences","text":"Aspect swww gSlapper Process Model Single daemon One process per wallpaper (optional) State Storage In-memory cache File-based (text) Restoration Automatic on daemon start Explicit <code>--restore</code> flag Systemd Type <code>simple</code> <code>notify</code> (wait for ready) Reload Support No Yes (<code>SIGHUP</code>) State Detail Cache of images Full config + video position"},{"location":"development/systemd-service/#future-enhancements","title":"Future Enhancements","text":"<p>Planned (see TO_IMPLEMENT.md): 1. Playlist Support - Rotate through multiple wallpapers 2. Scheduled Wallpapers - Change based on time of day 3. State Encryption - Optional encryption for sensitive paths 4. Multiple State Profiles - Switch between wallpaper configurations</p>"},{"location":"development/systemd-service/#see-also","title":"See Also","text":"<ul> <li>Systemd Service Setup (User Guide) - End-user setup guide</li> <li>State Management (Implementation) - State file API</li> <li>API Reference - Full API documentation</li> <li>Architecture - Overall system architecture</li> <li>TO_IMPLEMENT.md - Future enhancements</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to gSlapper! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install gSlapper on your system using one of the methods below.</p> <ul> <li>Install from Source - Build from source code</li> <li>Quick Start - Get running in minutes</li> </ul>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Basic configuration options and setup.</p> <ul> <li>Configuration Guide - All available options</li> </ul>"},{"location":"getting-started/#migration","title":"Migration","text":"<p>Already using another wallpaper tool? See our migration guide.</p> <ul> <li>Migration Guide - Switching from swww or mpvpaper</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After installation, explore the User Guide for complete usage documentation.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>gSlapper uses configuration files compatible with mpvpaper.</p>"},{"location":"getting-started/configuration/#configuration-directory","title":"Configuration Directory","text":"<p>Configuration files are located in:</p> <pre><code>~/.config/mpvpaper/\n</code></pre>"},{"location":"getting-started/configuration/#pause-list","title":"Pause List","text":"<p>Create <code>~/.config/mpvpaper/pauselist</code> to specify applications that should pause wallpaper playback when they're in fullscreen:</p> <pre><code>firefox\nchromium\nmpv\nvlc\n</code></pre> <p>Each line should contain the application name (as it appears in window titles).</p>"},{"location":"getting-started/configuration/#stop-list","title":"Stop List","text":"<p>Create <code>~/.config/mpvpaper/stoplist</code> to specify applications that should stop wallpaper playback:</p> <pre><code>games\n</code></pre>"},{"location":"getting-started/configuration/#auto-pausestop-options","title":"Auto-Pause/Stop Options","text":"<p>You can also enable auto-pause/stop via command line:</p> <pre><code># Auto-pause when wallpaper is hidden\ngslapper -p -o \"loop\" DP-1 video.mp4\n\n# Auto-stop when wallpaper is hidden\ngslapper -s -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Currently, gSlapper doesn't support environment variables for configuration. This may be added in future versions.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#arch-linux","title":"Arch Linux","text":"<p>Install from AUR:</p> <pre><code>yay -S gslapper\n</code></pre>"},{"location":"getting-started/installation/#manual-build","title":"Manual Build","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Arch Linux: <pre><code># Runtime dependencies\nsudo pacman -S gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav\n\n# Build dependencies\nsudo pacman -S meson ninja wayland-protocols\n</code></pre></p> <p>Ubuntu/Debian: <pre><code># Runtime dependencies\nsudo apt install gstreamer1.0-tools gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\\n                 gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav\n\n# Build dependencies\nsudo apt install meson ninja-build wayland-protocols libunwind-dev\n</code></pre></p>"},{"location":"getting-started/installation/#build-steps","title":"Build Steps","text":"<pre><code>git clone https://github.com/Nomadcxx/gSlapper.git\ncd gSlapper\nmeson setup build --prefix=/usr/local\nninja -C build\nsudo ninja -C build install\n</code></pre>"},{"location":"getting-started/installation/#codec-support","title":"Codec Support","text":"<p>Codec Support</p> <p><code>gst-plugins-ugly</code> and <code>gst-libav</code> provide codec support (H.264, H.265, etc.). Without these, videos may fail to play with \"Pipeline failed to reach playing state\" error.</p>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>After installation, verify gSlapper is working:</p> <pre><code>gslapper --help\n</code></pre> <p>You should see the help message with available options.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get gSlapper running in under a minute!</p>"},{"location":"getting-started/quick-start/#basic-video-wallpaper","title":"Basic Video Wallpaper","text":"<pre><code>gslapper DP-1 /path/to/video.mp4\n</code></pre> <p>Replace <code>DP-1</code> with your monitor name (use <code>gslapper -d</code> to list available monitors).</p>"},{"location":"getting-started/quick-start/#basic-image-wallpaper","title":"Basic Image Wallpaper","text":"<pre><code>gslapper DP-1 /path/to/wallpaper.jpg\n</code></pre> <p>Images default to \"fill\" mode, which fills the screen while maintaining aspect ratio.</p>"},{"location":"getting-started/quick-start/#with-looping","title":"With Looping","text":"<pre><code>gslapper -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"getting-started/quick-start/#all-monitors","title":"All Monitors","text":"<pre><code>gslapper -o \"loop\" '*' /path/to/video.mp4\n</code></pre>"},{"location":"getting-started/quick-start/#background-mode","title":"Background Mode","text":"<p>Run in the background:</p> <pre><code>gslapper -f -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"getting-started/quick-start/#making-wallpapers-persistent","title":"Making Wallpapers Persistent","text":"<p>To make your wallpaper survive reboots and logins, see the Persistent Wallpapers guide. It covers: - Systemd service setup (recommended) - Shell script startup - Compositor-specific configuration - Manual restoration</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Video Wallpapers</li> <li>Explore Static Images</li> <li>Set up Persistent Wallpapers for automatic restoration</li> <li>Set up IPC Control for runtime control</li> <li>Check Scaling Modes for display options</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This tutorial shows you how to use gSlapper with most of its features, step by step.</p> <p>Each section gradually builds on previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific wallpaper needs.</p> <p>It is also built to work as a future reference so you can come back and see exactly what you need.</p>"},{"location":"user-guide/#tutorial-sections","title":"Tutorial Sections","text":""},{"location":"user-guide/#first-steps","title":"First Steps","text":"<p>Basic setup and running gSlapper with video or static wallpapers.</p> <ul> <li>First Steps - Basic Video Wallpaper</li> <li>Static Images - Getting Started</li> </ul>"},{"location":"user-guide/#core-features","title":"Core Features","text":"<p>Essential functionality for everyday wallpaper management.</p> <ul> <li>Scaling Modes - Fill, stretch, original, panscan</li> <li>Multi-Monitor Setup - Independent control per display</li> <li>Persistent Wallpapers - Survive reboots and logins</li> </ul>"},{"location":"user-guide/#advanced-features","title":"Advanced Features","text":"<p>Additional capabilities for power users and complex setups.</p> <ul> <li>IPC Control - Runtime control via Unix socket</li> <li>Transitions - Smooth wallpaper transitions</li> <li>Command Line Options - All available flags</li> </ul>"},{"location":"user-guide/#migration","title":"Migration","text":"<p>Coming from other wallpaper tools?</p> <ul> <li>Migration Guide - Switching from swww or mpvpaper</li> </ul> <p>Tip: Each page has progressive navigation. Use the links below each section to continue your learning journey.</p>"},{"location":"user-guide/command-line-options/","title":"Command Line Options","text":""},{"location":"user-guide/command-line-options/#basic-options","title":"Basic Options","text":""},{"location":"user-guide/command-line-options/#-v-verbose","title":"<code>-v, --verbose</code>","text":"<p>Enable verbose output. Use <code>-vv</code> for more detail.</p> <pre><code>gslapper -v DP-1 video.mp4\ngslapper -vv DP-1 video.mp4  # More verbose\n</code></pre>"},{"location":"user-guide/command-line-options/#-f-fork","title":"<code>-f, --fork</code>","text":"<p>Fork to background after starting.</p> <pre><code>gslapper -f -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#-d-help-output","title":"<code>-d, --help-output</code>","text":"<p>Display all available outputs and quit.</p> <pre><code>gslapper -d\n</code></pre>"},{"location":"user-guide/command-line-options/#-h-help","title":"<code>-h, --help</code>","text":"<p>Display help message.</p> <pre><code>gslapper --help\n</code></pre>"},{"location":"user-guide/command-line-options/#playback-control","title":"Playback Control","text":""},{"location":"user-guide/command-line-options/#-p-auto-pause","title":"<code>-p, --auto-pause</code>","text":"<p>Automatically pause when wallpaper is hidden.</p> <pre><code>gslapper -p -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#-s-auto-stop","title":"<code>-s, --auto-stop</code>","text":"<p>Automatically stop when wallpaper is hidden.</p> <pre><code>gslapper -s -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#display-options","title":"Display Options","text":""},{"location":"user-guide/command-line-options/#-l-layer-layer","title":"<code>-l, --layer LAYER</code>","text":"<p>Specify shell surface layer. Options:</p> <ul> <li><code>background</code> (default)</li> <li><code>bottom</code></li> <li><code>top</code></li> <li><code>overlay</code></li> </ul> <pre><code>gslapper -l overlay DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#ipc-options","title":"IPC Options","text":""},{"location":"user-guide/command-line-options/#-i-ipc-socket-path","title":"<code>-I, --ipc-socket PATH</code>","text":"<p>Enable IPC control via Unix socket.</p> <pre><code>gslapper -I /tmp/gslapper.sock DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#video-options","title":"Video Options","text":""},{"location":"user-guide/command-line-options/#-o-gst-options-options","title":"<code>-o, --gst-options \"OPTIONS\"</code>","text":"<p>Pass options to GStreamer. Space-separated list:</p> <ul> <li><code>loop</code> - Seamless video looping</li> <li><code>fill</code> - Fill screen maintaining aspect ratio (default for images)</li> <li><code>panscan=X</code> - Scale video (0.0-1.0, default 1.0)</li> <li><code>stretch</code> - Stretch to fill screen (ignore aspect ratio)</li> <li><code>original</code> - Display at native resolution</li> <li><code>no-audio</code> - Disable audio playback</li> </ul> <pre><code>gslapper -o \"loop panscan=0.8\" DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/command-line-options/#transition-options","title":"Transition Options","text":""},{"location":"user-guide/command-line-options/#-transition-type-type","title":"<code>--transition-type TYPE</code>","text":"<p>Set transition effect type. Options:</p> <ul> <li><code>none</code> (default)</li> <li><code>fade</code></li> </ul> <pre><code>gslapper --transition-type fade -I /tmp/sock DP-1 image.jpg\n</code></pre>"},{"location":"user-guide/command-line-options/#-transition-duration-secs","title":"<code>--transition-duration SECS</code>","text":"<p>Set transition duration in seconds (default: 0.5).</p> <pre><code>gslapper --transition-type fade --transition-duration 2.0 -I /tmp/sock DP-1 image.jpg\n</code></pre>"},{"location":"user-guide/command-line-options/#systemd-options","title":"Systemd Options","text":""},{"location":"user-guide/command-line-options/#-s-systemd","title":"<code>-S, --systemd</code>","text":"<p>Enable systemd service mode. Enables systemd readiness notifications.</p> <pre><code>gslapper -S --restore DP-1 /path/to/video.mp4\n</code></pre> <p>Use Case: Only needed when running as systemd user service. The service files (<code>gslapper.service</code>, <code>gslapper@.service</code>) automatically include this flag.</p>"},{"location":"user-guide/command-line-options/#-r-restore","title":"<code>-R, --restore</code>","text":"<p>Restore wallpaper from saved state file.</p> <pre><code># Restore for specific output\ngslapper -R DP-1\n\n# Restore for all monitors\ngslapper -R '*'\n</code></pre> <p>Behavior: Loads state from <code>~/.local/state/gslapper/state-&lt;output&gt;.txt</code> (or <code>state.txt</code> for <code>'*')</code> and resumes wallpaper with saved video position and pause state.</p>"},{"location":"user-guide/command-line-options/#state-management-options","title":"State Management Options","text":""},{"location":"user-guide/command-line-options/#-save-state","title":"<code>--save-state</code>","text":"<p>Save current wallpaper state and exit.</p> <pre><code>gslapper -o \"loop\" DP-1 /path/to/video.mp4\n# Later, save state\ngslapper --save-state\n</code></pre> <p>Use Case: Manual state save without stopping gSlapper. Also available via IPC: <code>echo \"save-state\" | nc -U /tmp/sock</code>.</p>"},{"location":"user-guide/command-line-options/#-state-file-path","title":"<code>--state-file &lt;path&gt;</code>","text":"<p>Use custom state file path (instead of default).</p> <pre><code>gslapper --state-file /tmp/my-state.txt --restore DP-1\n</code></pre> <p>Default Location: <code>~/.local/state/gslapper/state-&lt;output&gt;.txt</code> (or <code>$XDG_STATE_HOME/gslapper/</code> if set).</p>"},{"location":"user-guide/command-line-options/#-no-save-state","title":"<code>--no-save-state</code>","text":"<p>Disable automatic state saving on exit.</p> <pre><code>gslapper --no-save-state -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre> <p>Use Case: Testing or temporary wallpapers where you don't want state saved.</p>"},{"location":"user-guide/command-line-options/#examples","title":"Examples","text":"<pre><code># Basic video with looping\ngslapper -o \"loop\" DP-1 video.mp4\n\n# Image with fill mode and IPC\ngslapper -o \"fill\" -I /tmp/sock DP-1 image.jpg\n\n# Video with auto-pause and verbose output\ngslapper -v -p -o \"loop\" DP-1 video.mp4\n\n# Background mode with transitions\ngslapper -f --transition-type fade --transition-duration 1.5 -I /tmp/sock DP-1 image.jpg\n</code></pre>"},{"location":"user-guide/ipc-control/","title":"IPC Control","text":"<p>gSlapper supports runtime control via Unix domain sockets, allowing you to control playback from scripts or other applications.</p>"},{"location":"user-guide/ipc-control/#enabling-ipc","title":"Enabling IPC","text":"<p>Start gSlapper with the <code>-I</code> or <code>--ipc-socket</code> option:</p> <pre><code>gslapper -I /tmp/gslapper.sock -o \"loop\" DP-1 video.mp4\n</code></pre>"},{"location":"user-guide/ipc-control/#sending-commands","title":"Sending Commands","text":"<p>Use <code>nc</code> (netcat) or <code>socat</code> to send commands:</p> <pre><code># Using nc\necho \"pause\" | nc -U /tmp/gslapper.sock\n\n# Using socat\necho \"pause\" | socat - UNIX-CONNECT:/tmp/gslapper.sock\n</code></pre>"},{"location":"user-guide/ipc-control/#available-commands","title":"Available Commands","text":""},{"location":"user-guide/ipc-control/#pause","title":"<code>pause</code>","text":"<p>Pause video playback.</p> <pre><code>echo \"pause\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK</code></p>"},{"location":"user-guide/ipc-control/#resume","title":"<code>resume</code>","text":"<p>Resume paused playback.</p> <pre><code>echo \"resume\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK</code></p>"},{"location":"user-guide/ipc-control/#query","title":"<code>query</code>","text":"<p>Get current state and wallpaper path.</p> <pre><code>echo \"query\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>STATUS: playing image /path/to/wallpaper.jpg</code> or <code>STATUS: paused video /path/to/video.mp4</code></p>"},{"location":"user-guide/ipc-control/#change-path","title":"<code>change &lt;path&gt;</code>","text":"<p>Switch to a different wallpaper.</p> <pre><code>echo \"change /path/to/new/video.mp4\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK: transition started</code> (if transitions enabled) or <code>OK</code></p>"},{"location":"user-guide/ipc-control/#stop","title":"<code>stop</code>","text":"<p>Stop gSlapper.</p> <pre><code>echo \"stop\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK</code> (gSlapper exits)</p>"},{"location":"user-guide/ipc-control/#set-transition-type","title":"<code>set-transition &lt;type&gt;</code>","text":"<p>Set transition effect type. Options: <code>none</code>, <code>fade</code>.</p> <pre><code>echo \"set-transition fade\" | nc -U /tmp/gslapper.sock\necho \"set-transition none\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK</code> or <code>ERROR: &lt;message&gt;</code></p> <p>Transitions</p> <p>Transitions only work between static images. Videos always use instant switch regardless of transition settings.</p>"},{"location":"user-guide/ipc-control/#set-transition-duration-seconds","title":"<code>set-transition-duration &lt;seconds&gt;</code>","text":"<p>Set transition duration in seconds (0.0-5.0).</p> <pre><code>echo \"set-transition-duration 2.0\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>OK</code> or <code>ERROR: &lt;message&gt;</code></p>"},{"location":"user-guide/ipc-control/#get-transition","title":"<code>get-transition</code>","text":"<p>Query current transition settings.</p> <pre><code>echo \"get-transition\" | nc -U /tmp/gslapper.sock\n</code></pre> <p>Response: <code>TRANSITION: &lt;type&gt; &lt;enabled|disabled&gt; &lt;duration&gt;</code></p> <p>Example: <code>TRANSITION: fade enabled 1.50</code></p>"},{"location":"user-guide/ipc-control/#response-format","title":"Response Format","text":"<ul> <li><code>OK</code> - Command succeeded</li> <li><code>OK: &lt;message&gt;</code> - Command succeeded with additional info</li> <li><code>ERROR: &lt;message&gt;</code> - Command failed with error message</li> <li><code>STATUS: &lt;state&gt; &lt;type&gt; &lt;path&gt;</code> - Query response</li> <li><code>TRANSITION: &lt;type&gt; &lt;enabled|disabled&gt; &lt;duration&gt;</code> - Transition query response</li> </ul>"},{"location":"user-guide/ipc-control/#example-script","title":"Example Script","text":"<pre><code>#!/bin/bash\nSOCKET=\"/tmp/gslapper.sock\"\n\ncase \"$1\" in\n    pause)\n        echo \"pause\" | nc -U \"$SOCKET\"\n        ;;\n    resume)\n        echo \"resume\" | nc -U \"$SOCKET\"\n        ;;\n    next)\n        echo \"change /path/to/next/video.mp4\" | nc -U \"$SOCKET\"\n        ;;\n    status)\n        echo \"query\" | nc -U \"$SOCKET\"\n        ;;\n    transition)\n        echo \"set-transition fade\" | nc -U \"$SOCKET\"\n        echo \"set-transition-duration 2.0\" | nc -U \"$SOCKET\"\n        ;;\n    *)\n        echo \"Usage: $0 {pause|resume|next|status|transition}\"\n        exit 1\n        ;;\nesac\n</code></pre>"},{"location":"user-guide/ipc-control/#future-commands","title":"Future Commands","text":"<p>The following commands are planned for future releases:</p> <ul> <li><code>preload &lt;path&gt;</code> - Preload image into cache</li> <li><code>unload &lt;path&gt;</code> - Remove image from cache</li> <li><code>list</code> - List preloaded images</li> </ul>"},{"location":"user-guide/migration-guide/","title":"Migration Guide","text":"<p>This guide helps users migrate from other wallpaper tools to gSlapper. Whether you're coming from swww, mpvpaper, hyprpaper, swaybg, or feh, we'll show you how to make the switch smoothly.</p>"},{"location":"user-guide/migration-guide/#why-migrate-to-gslapper","title":"Why Migrate to gSlapper?","text":"<p>Key Advantages: - \u2705 Video + Static Support - One tool for both animated and static wallpapers - \u2705 GStreamer Backend - More efficient than libmpv, better NVIDIA compatibility - \u2705 Minimal Resource Usage - Smart texture management and frame rate limiting - \u2705 Wayland Native - Built for wlroots compositors (Hyprland, Sway, River, Niri) - \u2705 IPC Control - Runtime control via Unix sockets - \u2705 Persistent State - Automatic wallpaper restoration on login - \u2705 Smooth Transitions - Fade effects between static images</p>"},{"location":"user-guide/migration-guide/#migrating-from-swww","title":"Migrating from swww","text":""},{"location":"user-guide/migration-guide/#swww-vs-gslapper-comparison","title":"swww vs gSlapper Comparison","text":"Feature swww gSlapper Static Images \u2705 \u2705 Video Wallpapers \u274c (images only) \u2705 Daemon <code>swww-daemon</code> Optional systemd service Transitions \u2705 (fade) \u2705 (fade) Scaling Limited Full (fill, stretch, original, panscan) Multi-Monitor \u2705 \u2705 IPC Control \u2705 \u2705 Resource Usage Medium Low (smart management) Video Support GIF only Full GStreamer (MP4, MKV, WebM)"},{"location":"user-guide/migration-guide/#swww-commands-gslapper-equivalents","title":"swww Commands \u2192 gSlapper Equivalents","text":""},{"location":"user-guide/migration-guide/#basic-usage","title":"Basic Usage","text":"<p>swww: <pre><code># Set wallpaper on all monitors\nswww img /path/to/image.jpg\n\n# Set on specific monitor\nswww img -o DP-1 /path/to/image.jpg\n\n# With transition\nswww img -t fade --transition-step 90 /path/to/image.jpg\n</code></pre></p> <p>gSlapper (static images): <pre><code># Set wallpaper on all monitors\ngslapper -o \"fill\" '*' /path/to/image.jpg\n\n# Set on specific monitor\ngslapper -o \"fill\" DP-1 /path/to/image.jpg\n\n# With transition\ngslapper -o \"fill\" --transition-type fade --transition-duration 0.5 DP-1 /path/to/image.jpg\n</code></pre></p>"},{"location":"user-guide/migration-guide/#video-wallpapers-new-in-gslapper","title":"Video Wallpapers (NEW in gSlapper)","text":"<pre><code># Set video wallpaper with looping\ngslapper -o \"loop\" DP-1 /path/to/video.mp4\n\n# Video with custom scaling\ngslapper -o \"loop panscan=0.8\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/migration-guide/#scaling-modes","title":"Scaling Modes","text":"swww gSlapper Description <code>--no-resize</code> <code>-o \"original\"</code> Native resolution <code>--cover</code> <code>-o \"fill\"</code> Cover screen, crop excess <code>--contain</code> <code>-o \"panscan=1.0\"</code> Fit inside, keep aspect"},{"location":"user-guide/migration-guide/#daemonservice","title":"Daemon/Service","text":"<p>swww: <pre><code># Start daemon manually\nswww-daemon\n\n# Or via systemd\nsystemctl --user enable swww-daemon.service\nsystemctl --user start swww-daemon.service\n</code></pre></p> <p>gSlapper: <pre><code># No daemon needed for static images (one-shot like swww init)\n# But you can use systemd for persistence:\n\n# Create environment file\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n\n# Enable service\nsystemctl --user enable --now gslapper.service\n</code></pre></p>"},{"location":"user-guide/migration-guide/#cache-management","title":"Cache Management","text":"<p>swww: <pre><code>swww clear-cache\nswww img --no-cache /path/to/image.jpg\n</code></pre></p> <p>gSlapper: <pre><code># gSlapper doesn't use a persistent cache\n# Transitions are handled in-memory\n# TODO: Preload cache coming soon (see TO_IMPLEMENT.md)\n</code></pre></p>"},{"location":"user-guide/migration-guide/#swww-config-gslapper","title":"swww Config \u2192 gSlapper","text":"<p>swww config (<code>~/.config/swww/init.sh</code>): <pre><code>#!/bin/bash\nswww init\nswww img /path/to/wallpaper.jpg\n</code></pre></p> <p>gSlapper equivalent: <pre><code>#!/bin/bash\n# Method 1: One-shot (no daemon)\ngslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n\n# Method 2: Systemd service for persistence\n# See: Persistent Wallpapers guide\n</code></pre></p>"},{"location":"user-guide/migration-guide/#migration-checklist-swww-users","title":"Migration Checklist - swww Users","text":"<ul> <li>[ ] Replace <code>swww img</code> commands with <code>gslapper -o \"fill\"</code> for static images</li> <li>[ ] Use <code>gslapper -o \"loop\"</code> for video wallpapers (new capability)</li> <li>[ ] Update compositor startup scripts</li> <li>Hyprland: Change <code>exec-once = swww img ...</code> to <code>exec-once = gslapper ...</code></li> <li>Sway: Change <code>exec swww img ...</code> to <code>exec gslapper ...</code></li> <li>[ ] Disable <code>swww-daemon</code> if using gSlapper service:   <pre><code>systemctl --user disable swww-daemon.service\n</code></pre></li> <li>[ ] Update shell aliases (if any):   <pre><code># Old\nalias wp='swww img ~/Pictures/wallpaper.jpg'\n\n# New\nalias wp='gslapper -o \"fill\" ~/Pictures/wallpaper.jpg'\n</code></pre></li> </ul>"},{"location":"user-guide/migration-guide/#migrating-from-mpvpaper","title":"Migrating from mpvpaper","text":""},{"location":"user-guide/migration-guide/#mpvpaper-vs-gslapper-comparison","title":"mpvpaper vs gSlapper Comparison","text":"Feature mpvpaper gSlapper Static Images \u2705 \u2705 Video Wallpapers \u2705 \u2705 Backend libmpv GStreamer Memory Leaks \u26a0\ufe0f Issues on NVIDIA \u2705 Fixed GPU Resource Usage High Optimized Multi-Monitor \u2705 \u2705 IPC Control \u2705 \u2705 Transitions \u274c \u2705 Scaling Modes Limited Full (fill, stretch, original, panscan) Persistent State No \u2705 Automatic"},{"location":"user-guide/migration-guide/#why-switch-from-mpvpaper","title":"Why Switch from mpvpaper?","text":"<p>Known Issues Fixed in gSlapper: - \u2705 NVIDIA Memory Leaks - GStreamer backend solves libmpv memory issues - \u2705 GPU Resource Usage - Smart texture management reduces VRAM consumption - \u2705 Static Image Transitions - Fade effects not available in mpvpaper - \u2705 Persistent State - Automatic wallpaper restoration, no manual scripts needed</p>"},{"location":"user-guide/migration-guide/#mpvpaper-commands-gslapper-equivalents","title":"mpvpaper Commands \u2192 gSlapper Equivalents","text":""},{"location":"user-guide/migration-guide/#basic-usage_1","title":"Basic Usage","text":"<p>mpvpaper: <pre><code># Video wallpaper\nmpvpaper -f --loop DP-1 /path/to/video.mp4\n\n# Video with options\nmpvpaper -f --loop --panscan=1.0 DP-1 /path/to/video.mp4\n\n# Static image\nmpvpaper DP-1 /path/to/image.jpg\n</code></pre></p> <p>gSlapper: <pre><code># Video wallpaper\ngslapper -f -o \"loop\" DP-1 /path/to/video.mp4\n\n# Video with options\ngslapper -f -o \"loop panscan=1.0\" DP-1 /path/to/video.mp4\n\n# Static image (fill mode by default)\ngslapper DP-1 /path/to/image.jpg\n\n# Or explicit fill mode\ngslapper -o \"fill\" DP-1 /path/to/image.jpg\n</code></pre></p>"},{"location":"user-guide/migration-guide/#scalingpanscan","title":"Scaling/Panscan","text":"<p>mpvpaper: <pre><code># Full stretch\nmpvpaper -f DP-1 video.mp4\n\n# Panscan (0.0 = fit, 1.0 = fill)\nmpvpaper -f --panscan=0.5 DP-1 video.mp4\n</code></pre></p> <p>gSlapper: <pre><code># Full stretch\ngslapper -f -o \"stretch\" DP-1 video.mp4\n\n# Panscan (0.0 = fit, 1.0 = fill)\ngslapper -f -o \"panscan=0.5\" DP-1 video.mp4\n</code></pre></p>"},{"location":"user-guide/migration-guide/#auto-pausestop","title":"Auto-Pause/Stop","text":"<p>mpvpaper: <pre><code># Uses ~/.config/mpvpaper/pauselist and stoplist\n# Add application names to files\n</code></pre></p> <p>gSlapper: <pre><code># Same configuration files\necho \"firefox\" &gt;&gt; ~/.config/mpvpaper/pauselist\necho \"games\" &gt;&gt; ~/.config/mpvpaper/stoplist\n\n# Or use command-line flags\ngslapper -p -o \"loop\" DP-1 video.mp4  # Auto-pause\ngslapper -s -o \"loop\" DP-1 video.mp4  # Auto-stop\n</code></pre></p>"},{"location":"user-guide/migration-guide/#ipc-control","title":"IPC Control","text":"<p>mpvpaper: <pre><code># No built-in IPC\n# Requires external tools or scripts\n</code></pre></p> <p>gSlapper: <pre><code># Start with IPC socket\ngslapper -I /tmp/gslapper.sock -o \"loop\" DP-1 video.mp4\n\n# Control via IPC\necho \"pause\" | nc -U /tmp/gslapper.sock\necho \"resume\" | nc -U /tmp/gslapper.sock\necho \"change /new/video.mp4\" | nc -U /tmp/gslapper.sock\n</code></pre></p>"},{"location":"user-guide/migration-guide/#mpvpaper-systemd-gslapper","title":"mpvpaper Systemd \u2192 gSlapper","text":"<p>mpvpaper service: <pre><code>[Unit]\nDescription=mpvpaper service\nAfter=graphical-session.target\n\n[Service]\nType=simple\nExecStart=/usr/bin/mpvpaper -f --loop DP-1 /path/to/video.mp4\nRestart=on-failure\n\n[Install]\nWantedBy=default.target\n</code></pre></p> <p>gSlapper equivalent: <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore DP-1\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\nTimeoutStopSec=30\n\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\nMemoryMax=512M\nCPUQuota=50%\nNoNewPrivileges=true\nPrivateTmp=true\n\n[Install]\nWantedBy=default.target\n</code></pre></p> <p>Key Differences: - <code>--systemd --restore</code> enables state persistence - <code>Type=notify</code> for systemd readiness - Resource limits for better management - SIGHUP reload support for state saving</p>"},{"location":"user-guide/migration-guide/#migration-checklist-mpvpaper-users","title":"Migration Checklist - mpvpaper Users","text":"<ul> <li>[ ] Replace <code>mpvpaper</code> with <code>gslapper</code> in all scripts</li> <li>[ ] Update systemd services   <pre><code>systemctl --user disable mpvpaper.service\nsystemctl --user enable gslapper.service\n</code></pre></li> <li>[ ] Create environment file for gSlapper:   <pre><code>mkdir -p ~/.config/gslapper\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n</code></pre></li> <li>[ ] Test video playback (should work better on NVIDIA)</li> <li>[ ] Try fade transitions with static images</li> <li>[ ] Set up IPC socket for runtime control</li> <li>[ ] Update compositor startup scripts</li> </ul>"},{"location":"user-guide/migration-guide/#migrating-from-hyprpaper","title":"Migrating from hyprpaper","text":""},{"location":"user-guide/migration-guide/#hyprpaper-vs-gslapper-comparison","title":"hyprpaper vs gSlapper Comparison","text":"Feature hyprpaper gSlapper Static Images \u2705 \u2705 Video Wallpapers \u274c \u2705 Hyprland Only \u2705 \u2705 (but works on any wlroots compositor) Daemon \u2705 (<code>hyprpaper</code>) Optional systemd service Preloading \u2705 \u26a0\ufe0f TODO (coming soon) Transitions \u274c \u2705 Scaling Basic Full (fill, stretch, original, panscan) IPC Control \u274c \u2705 Multi-Monitor \u2705 \u2705"},{"location":"user-guide/migration-guide/#hyprpaper-commands-gslapper-equivalents","title":"hyprpaper Commands \u2192 gSlapper Equivalents","text":""},{"location":"user-guide/migration-guide/#basic-usage_2","title":"Basic Usage","text":"<p>hyprpaper: <pre><code># Start daemon\nhyprpaper &amp;\n\n# Preload images\nhyprpaper preload /path/to/image1.jpg\nhyprpaper preload /path/to/image2.jpg\n\n# Set wallpaper\nhyprpaper wallpaper \"DP-1,/path/to/image1.jpg\"\nhyprpaper wallpaper \"DP-2,/path/to/image2.jpg\"\n</code></pre></p> <p>gSlapper: <pre><code># Set wallpaper directly (no daemon required)\ngslapper -o \"fill\" DP-1 /path/to/image1.jpg\n\n# For multiple monitors (different wallpapers)\ngslapper -o \"fill\" DP-1 /path/to/image1.jpg &amp;\ngslapper -o \"fill\" DP-2 /path/to/image2.jpg &amp;\n\n# Or use systemd service for persistence\n# See: Persistent Wallpapers guide\n</code></pre></p>"},{"location":"user-guide/migration-guide/#different-wallpapers-per-monitor","title":"Different Wallpapers per Monitor","text":"<p>hyprpaper (<code>~/.config/hypr/hyprpaper.conf</code>): <pre><code>wallpaper = DP-1,/path/to/image1.jpg\nwallpaper = DP-2,/path/to/image2.jpg\n</code></pre></p> <p>gSlapper (systemd template services): <pre><code># Enable per-monitor services\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-2.service\n\n# Each service has its own state file\n# Set wallpapers manually first\ngslapper -o \"fill\" DP-1 /path/to/image1.jpg  # Ctrl+C\ngslapper -o \"fill\" DP-2 /path/to/image2.jpg  # Ctrl+C\n</code></pre></p>"},{"location":"user-guide/migration-guide/#hyprpaper-config-gslapper","title":"hyprpaper Config \u2192 gSlapper","text":"<p>hyprpaper config (<code>~/.config/hypr/hyprpaper.conf</code>): <pre><code>wallpaper = DP-1,/path/to/wallpaper.jpg\nwallpaper = DP-2,/path/to/wallpaper2.jpg\nsplash = false\n</code></pre></p> <p>gSlapper equivalent (Hyprland config):</p> <p>Method 1: Compositor startup (quick setup) <pre><code># ~/.config/hypr/hyprland.conf\nexec-once = gslapper -o \"fill\" DP-1 /path/to/wallpaper.jpg\n</code></pre></p> <p>Method 2: Systemd service (recommended) <pre><code># Create environment\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n\n# Enable services\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-2.service\n</code></pre></p> <p>Method 3: Shell script (for manual control) <pre><code>#!/bin/bash\n# ~/.config/hypr/set-wallpapers.sh\ngslapper -o \"fill\" DP-1 /path/to/wallpaper.jpg &amp;\ngslapper -o \"fill\" DP-2 /path/to/wallpaper2.jpg &amp;\n</code></pre></p>"},{"location":"user-guide/migration-guide/#migration-checklist-hyprpaper-users","title":"Migration Checklist - hyprpaper Users","text":"<ul> <li>[ ] Kill <code>hyprpaper</code> daemon:   <pre><code>pkill hyprpaper\n</code></pre></li> <li>[ ] Remove from Hyprland config:   <pre><code># Comment out in ~/.config/hypr/hyprland.conf\n# exec-once = hyprpaper &amp;\n</code></pre></li> <li>[ ] Set up gSlapper via systemd (recommended) or compositor config</li> <li>[ ] Test with static images first</li> <li>[ ] Try video wallpapers (new feature not available in hyprpaper)</li> <li>[ ] Try fade transitions</li> <li>[ ] Remove hyprpaper config file if not needed</li> </ul>"},{"location":"user-guide/migration-guide/#migrating-from-swaybg","title":"Migrating from swaybg","text":""},{"location":"user-guide/migration-guide/#swaybg-vs-gslapper-comparison","title":"swaybg vs gSlapper Comparison","text":"Feature swaybg gSlapper Static Images \u2705 \u2705 Video Wallpapers \u274c \u2705 Sway Only \u2705 \u2705 (but works on any Wayland compositor) Daemon \u2705 (runs in bg) Optional systemd service Transitions \u274c \u2705 Scaling <code>stretch</code>/<code>fill</code> only Full modes IPC Control \u274c \u2705 Multi-Monitor \u2705 \u2705"},{"location":"user-guide/migration-guide/#swaybg-commands-gslapper-equivalents","title":"swaybg Commands \u2192 gSlapper Equivalents","text":""},{"location":"user-guide/migration-guide/#basic-usage_3","title":"Basic Usage","text":"<p>swaybg: <pre><code># Single monitor\nswaybg -i /path/to/image.jpg -m fill\n\n# Multiple monitors (different wallpapers)\nswaybg -i /path/to/image1.jpg -o DP-1 -m fill \\\n         -i /path/to/image2.jpg -o DP-2 -m fill\n\n# Scale modes\nswaybg -i /path/to/image.jpg -m stretch\nswaybg -i /path/to/image.jpg -m fit\n</code></pre></p> <p>gSlapper: <pre><code># Single monitor\ngslapper -o \"fill\" DP-1 /path/to/image.jpg\n\n# Multiple monitors\ngslapper -o \"fill\" DP-1 /path/to/image1.jpg &amp;\ngslapper -o \"fill\" DP-2 /path/to/image2.jpg &amp;\n\n# Scale modes\ngslapper -o \"stretch\" DP-1 /path/to/image.jpg\ngslapper -o \"original\" DP-1 /path/to/image.jpg\ngslapper -o \"panscan=1.0\" DP-1 /path/to/image.jpg  # Fit\n</code></pre></p>"},{"location":"user-guide/migration-guide/#sway-config-gslapper","title":"Sway Config \u2192 gSlapper","text":"<p>swaybg in Sway config (<code>~/.config/sway/config</code>): <pre><code># Single wallpaper\noutput * bg /path/to/wallpaper.jpg fill\n\n# Different per monitor\noutput DP-1 bg /path/to/wallpaper1.jpg fill\noutput DP-2 bg /path/to/wallpaper2.jpg fill\n\n# Scale modes\noutput DP-1 bg /path/to/wallpaper.jpg stretch\noutput DP-1 bg /path/to/wallpaper.jpg fit\n</code></pre></p> <p>gSlapper equivalent:</p> <p>Method 1: Exec in sway config <pre><code># Single wallpaper\nexec gslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n\n# Different per monitor (script)\nexec ~/.config/sway/set-wallpapers.sh\n</code></pre></p> <p>Method 2: Systemd service (recommended) <pre><code># Create environment\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n\n# Enable services\nsystemctl --user enable --now gslapper.service  # Single\n# Or per monitor:\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-2.service\n</code></pre></p> <p>Method 3: Script for sway exec <pre><code>#!/bin/bash\n# ~/.config/sway/set-wallpapers.sh\ngslapper -o \"fill\" DP-1 /path/to/wallpaper1.jpg &amp;\ngslapper -o \"fill\" DP-2 /path/to/wallpaper2.jpg &amp;\n</code></pre></p>"},{"location":"user-guide/migration-guide/#migration-checklist-swaybg-users","title":"Migration Checklist - swaybg Users","text":"<ul> <li>[ ] Remove <code>output * bg</code> lines from sway config:   <pre><code># Comment out in ~/.config/sway/config\n# output * bg /path/to/wallpaper.jpg fill\n</code></pre></li> <li>[ ] Kill any running swaybg instances:   <pre><code>pkill swaybg\n</code></pre></li> <li>[ ] Set up gSlapper via systemd (recommended) or sway exec</li> <li>[ ] Test static image wallpaper</li> <li>[ ] Try video wallpapers (new feature)</li> <li>[ ] Try fade transitions</li> <li>[ ] Enable IPC socket if you want runtime control</li> </ul>"},{"location":"user-guide/migration-guide/#migrating-from-feh","title":"Migrating from feh","text":""},{"location":"user-guide/migration-guide/#feh-vs-gslapper-comparison","title":"feh vs gSlapper Comparison","text":"Feature feh gSlapper Static Images \u2705 \u2705 Video Wallpapers \u274c \u2705 X11 Tool \u2705 \u274c (Wayland only) Xwayland Compatible \u2705 \u2705 (native Wayland better) Image Browser \u2705 \u274c Transitions \u274c \u2705 Scaling Full modes Full modes IPC Control \u274c \u2705 Multi-Monitor \u2705 \u2705 <p>Note: feh is an X11 tool. If you're using Wayland with Xwayland, gSlapper (native Wayland) will provide better performance and integration.</p>"},{"location":"user-guide/migration-guide/#feh-commands-gslapper-equivalents","title":"feh Commands \u2192 gSlapper Equivalents","text":""},{"location":"user-guide/migration-guide/#basic-usage_4","title":"Basic Usage","text":"<p>feh: <pre><code># Set wallpaper\nfeh --bg-fill /path/to/image.jpg\n\n# Specific monitor (with xrandr)\nfeh --bg-fill /path/to/image.jpg --output-name DP-1\n\n# Scale modes\nfeh --bg-scale /path/to/image.jpg    # Fit inside\nfeh --bg-tile /path/to/image.jpg     # Tile\nfeh --bg-center /path/to/image.jpg   # Center\n</code></pre></p> <p>gSlapper: <pre><code># Set wallpaper\ngslapper -o \"fill\" DP-1 /path/to/image.jpg\n\n# Scale modes\ngslapper -o \"panscan=1.0\" DP-1 /path/to/image.jpg  # Fit\ngslapper -o \"original\" DP-1 /path/to/image.jpg     # Center/native\n</code></pre></p>"},{"location":"user-guide/migration-guide/#feh-random-wallpaper-scripts","title":"feh Random Wallpaper Scripts","text":"<p>feh script: <pre><code>#!/bin/bash\n# feh random wallpaper\nDIR=\"$HOME/Pictures/Wallpapers\"\nIMAGE=$(find \"$DIR\" -type f | shuf -n 1)\nfeh --bg-fill \"$IMAGE\"\n</code></pre></p> <p>gSlapper equivalent: <pre><code>#!/bin/bash\n# gSlapper random wallpaper\nDIR=\"$HOME/Pictures/Wallpapers\"\nIMAGE=$(find \"$DIR\" -type f | shuf -n 1)\ngslapper -o \"fill\" '*' \"$IMAGE\"\n</code></pre></p>"},{"location":"user-guide/migration-guide/#feh-integration-in-compositors","title":"feh Integration in Compositors","text":"<p>Sway with feh: <pre><code># ~/.config/sway/config\nexec feh --bg-fill /path/to/wallpaper.jpg\n</code></pre></p> <p>gSlapper equivalent: <pre><code># ~/.config/sway/config\nexec gslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n</code></pre></p>"},{"location":"user-guide/migration-guide/#migration-checklist-feh-users","title":"Migration Checklist - feh Users","text":"<ul> <li>[ ] Ensure you're using Wayland (native Wayland is better than Xwayland)</li> <li>[ ] Remove feh from compositor config</li> <li>[ ] Kill any running feh instances:   <pre><code>pkill feh\n</code></pre></li> <li>[ ] Set up gSlapper (see tool-specific guides above)</li> <li>[ ] Test with static images</li> <li>[ ] Try video wallpapers (new feature)</li> <li>[ ] Try fade transitions</li> <li>[ ] Keep feh for image browsing if you like it (both can coexist)</li> </ul>"},{"location":"user-guide/migration-guide/#quick-reference-common-commands","title":"Quick Reference: Common Commands","text":""},{"location":"user-guide/migration-guide/#setting-static-wallpaper","title":"Setting Static Wallpaper","text":"Tool Command swww <code>swww img /path/to/image.jpg</code> mpvpaper <code>mpvpaper DP-1 /path/to/image.jpg</code> hyprpaper <code>hyprpaper wallpaper \"DP-1,/path/to/image.jpg\"</code> swaybg <code>swaybg -i /path/to/image.jpg -m fill -o DP-1</code> feh <code>feh --bg-fill /path/to/image.jpg</code> gSlapper <code>gslapper -o \"fill\" DP-1 /path/to/image.jpg</code>"},{"location":"user-guide/migration-guide/#setting-video-wallpaper","title":"Setting Video Wallpaper","text":"Tool Command swww \u274c Not supported mpvpaper <code>mpvpaper -f --loop DP-1 /path/to/video.mp4</code> hyprpaper \u274c Not supported swaybg \u274c Not supported feh \u274c Not supported gSlapper <code>gslapper -o \"loop\" DP-1 /path/to/video.mp4</code>"},{"location":"user-guide/migration-guide/#fade-transition","title":"Fade Transition","text":"Tool Command swww <code>swww img -t fade /path/to/image.jpg</code> mpvpaper \u274c Not supported hyprpaper \u274c Not supported swaybg \u274c Not supported feh \u274c Not supported gSlapper <code>gslapper --transition-type fade --transition-duration 0.5 DP-1 /path/to/image.jpg</code>"},{"location":"user-guide/migration-guide/#troubleshooting-migration-issues","title":"Troubleshooting Migration Issues","text":""},{"location":"user-guide/migration-guide/#compositor-still-starts-old-tool","title":"Compositor Still Starts Old Tool","text":"<p>Problem: Old wallpaper tool still runs on startup</p> <p>Solution: 1. Check compositor config files:    - Hyprland: <code>~/.config/hypr/hyprland.conf</code>    - Sway: <code>~/.config/sway/config</code>    - River: <code>~/.config/river/init</code>    - Niri: <code>~/.config/niri/config.kdl</code></p> <ol> <li> <p>Remove or comment out old tool:    <pre><code># Old\n# exec-once = hyprpaper &amp;\n\n# New\nexec-once = gslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n</code></pre></p> </li> <li> <p>Kill running instances:    <pre><code>pkill hyprpaper\npkill swaybg\npkill swww-daemon\n</code></pre></p> </li> </ol>"},{"location":"user-guide/migration-guide/#multiple-wallpaper-tools-running","title":"Multiple Wallpaper Tools Running","text":"<p>Problem: Conflicts between multiple wallpaper tools</p> <p>Solution: <pre><code># Check for running tools\nps aux | grep -E \"swww|mpvpaper|hyprpaper|swaybg|feh|gslapper\"\n\n# Kill old tools\nsystemctl --user stop swww-daemon.service\npkill -f \"mpvpaper|hyprpaper|swaybg|feh\"\n\n# Start gSlapper\ngslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n</code></pre></p>"},{"location":"user-guide/migration-guide/#wallpaper-not-showing","title":"Wallpaper Not Showing","text":"<p>Problem: gSlapper starts but no wallpaper visible</p> <p>Solutions: 1. Check output name:    <pre><code>gslapper -d  # List available outputs\n</code></pre></p> <ol> <li> <p>Check if file exists and is readable:    <pre><code>test -f /path/to/wallpaper.jpg &amp;&amp; echo \"OK\" || echo \"Missing\"\n</code></pre></p> </li> <li> <p>Check logs:    <pre><code># With verbose flag\ngslapper -vv DP-1 /path/to/wallpaper.jpg\n\n# Systemd logs\njournalctl --user -u gslapper.service -f\n</code></pre></p> </li> </ol>"},{"location":"user-guide/migration-guide/#transition-not-working","title":"Transition Not Working","text":"<p>Problem: Fade transition doesn't appear</p> <p>Cause: Transitions only work between static images, not videos</p> <p>Solution: <pre><code># Correct - static image to static image\ngslapper -o \"fill\" --transition-type fade DP-1 image1.jpg\n# Then:\necho \"change /path/to/image2.jpg\" | nc -U /tmp/gslapper.sock\n\n# Incorrect - video wallpaper\ngslapper -o \"loop\" DP-1 video.mp4  # No transition\n</code></pre></p>"},{"location":"user-guide/migration-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>Quick Start Guide - Get started with gSlapper</li> <li>Command Line Options - Full CLI reference</li> <li>Systemd Service Setup - Persistent wallpapers guide</li> <li>Persistent Wallpapers - Advanced persistence methods</li> <li>IPC Control - Runtime control guide</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"user-guide/migration-guide/#feature-comparison-summary","title":"Feature Comparison Summary","text":"Feature swww mpvpaper hyprpaper swaybg feh gSlapper Static Images \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Video Wallpapers \u274c \u2705 \u274c \u274c \u274c \u2705 Transitions \u2705 \u274c \u274c \u274c \u274c \u2705 IPC Control \u2705 \u274c \u274c \u274c \u274c \u2705 Preload Cache \u274c \u274c \u2705 \u274c \u274c \u26a0\ufe0f TODO Persistent State \u2705 \u274c \u274c \u274c \u274c \u2705 NVIDIA Friendly \u2705 \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 GPU Optimized Medium High Low Low Low Low Backend Custom libmpv Custom Custom X11 GStreamer Multi-Monitor \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 <p>gSlapper combines the best features: - Static images + videos (like mpvpaper) - Transitions (like swww) - IPC control (like swww) - Low GPU usage (better than mpvpaper) - No NVIDIA memory leaks (unlike mpvpaper) - Wayland native (unlike feh)</p>"},{"location":"user-guide/persistent-wallpapers/","title":"Persistent Wallpapers in Wayland","text":"<p>This guide explains how to set up persistent wallpapers (both video and static images) that automatically restore after reboot or login in Wayland.</p>"},{"location":"user-guide/persistent-wallpapers/#overview","title":"Overview","text":"<p>Unlike X11, Wayland doesn't have a built-in wallpaper system. Wallpapers are managed by compositor-specific tools or utilities like gSlapper. To make wallpapers persistent across reboots, you need to configure automatic startup.</p>"},{"location":"user-guide/persistent-wallpapers/#methods-for-persistent-wallpapers","title":"Methods for Persistent Wallpapers","text":""},{"location":"user-guide/persistent-wallpapers/#method-1-systemd-user-service-recommended","title":"Method 1: Systemd User Service (Recommended)","text":"<p>Best for: Automatic restoration, process management, integration with system lifecycle</p> <p>Advantages: - \u2705 Automatic startup on login - \u2705 Automatic restart on failure - \u2705 State restoration (video position, pause state) - \u2705 Process lifecycle management - \u2705 Logging via journalctl - \u2705 Proper Wayland environment handling</p> <p>Setup:</p> <ol> <li> <p>Create environment file: <pre><code>mkdir -p ~/.config/gslapper\necho \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n</code></pre></p> </li> <li> <p>Set initial wallpaper (saves state): <pre><code># Video wallpaper\ngslapper -o \"loop\" DP-1 /path/to/video.mp4\n# Press Ctrl+C to stop (state is saved automatically)\n\n# Static image\ngslapper -o \"fill\" DP-1 /path/to/image.jpg\n# Press Ctrl+C to stop\n</code></pre></p> </li> <li> <p>Create service file: <pre><code>mkdir -p ~/.config/systemd/user\n</code></pre></p> </li> </ol> <p>Copy the example service file: <pre><code>cp /usr/lib/systemd/user/gslapper.service ~/.config/systemd/user/gslapper.service\n</code></pre></p> <p>Or create manually (<code>~/.config/systemd/user/gslapper.service</code>): <pre><code>[Unit]\nDescription=gSlapper Wallpaper Service\nAfter=graphical-session.target\nWants=graphical-session.target\n\n[Service]\nType=notify\nExecStart=/usr/bin/gslapper --systemd --restore '*'\nExecReload=/bin/kill -HUP $MAINPID\nRestart=on-failure\nRestartSec=5\n\nEnvironmentFile=%h/.config/gslapper/environment\nEnvironment=XDG_RUNTIME_DIR=%t\n\n[Install]\nWantedBy=default.target\n</code></pre></p> <ol> <li>Enable and start: <pre><code>systemctl --user daemon-reload\nsystemctl --user enable --now gslapper.service\n</code></pre></li> </ol> <p>For per-monitor wallpapers: Use the template service (<code>gslapper@.service</code>): <pre><code>systemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-3.service\n</code></pre></p> <p>See also: Systemd Service Setup for detailed instructions.</p>"},{"location":"user-guide/persistent-wallpapers/#method-2-shell-script-in-startup-files","title":"Method 2: Shell Script in Startup Files","text":"<p>Best for: Simple setup, no systemd knowledge required, quick configuration</p> <p>Advantages: - \u2705 Simple - just add to shell config - \u2705 Works on systems without systemd - \u2705 Full control over startup timing</p> <p>Disadvantages: - \u274c No automatic restart on failure - \u274c No process management - \u274c Manual state restoration needed - \u274c Environment variables must be set manually</p> <p>Setup:</p> <ol> <li>Add to shell config (<code>~/.bashrc</code>, <code>~/.zshrc</code>, or <code>~/.config/fish/config.fish</code>):</li> </ol> <p>For bash/zsh: <pre><code># Start gSlapper on login\nif [ -z \"$WAYLAND_DISPLAY\" ]; then\n    export WAYLAND_DISPLAY=wayland-0  # Adjust if needed\nfi\n\n# Restore wallpaper (requires state file to exist)\ngslapper --restore DP-1 &amp;\n</code></pre></p> <p>For fish: <pre><code># Start gSlapper on login\nif not set -q WAYLAND_DISPLAY\n    set -gx WAYLAND_DISPLAY wayland-0\nend\n\n# Restore wallpaper\ngslapper --restore DP-1 &amp;\n</code></pre></p> <ol> <li>Set initial wallpaper first: <pre><code>gslapper -o \"loop\" DP-1 /path/to/video.mp4\n# Press Ctrl+C (saves state)\n</code></pre></li> </ol> <p>Note: This method requires you to manually set the wallpaper once to create the state file.</p>"},{"location":"user-guide/persistent-wallpapers/#method-3-compositor-specific-startup","title":"Method 3: Compositor-Specific Startup","text":"<p>Best for: Integration with compositor configuration</p>"},{"location":"user-guide/persistent-wallpapers/#hyprland","title":"Hyprland","text":"<p>Add to <code>~/.config/hypr/hyprland.conf</code>: <pre><code>exec-once = gslapper --restore DP-1\n</code></pre></p> <p>Or with a delay to ensure Wayland is ready: <pre><code>exec-once = sleep 1 &amp;&amp; gslapper --restore DP-1\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#sway","title":"Sway","text":"<p>Add to <code>~/.config/sway/config</code>: <pre><code>exec gslapper --restore DP-1\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#river","title":"River","text":"<p>Add to <code>~/.config/river/init</code>: <pre><code>gslapper --restore DP-1 &amp;\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#niri","title":"Niri","text":"<p>Add to <code>~/.config/niri/config.kdl</code>: <pre><code>spawn-at-startup {\n    gslapper --restore DP-1\n}\n</code></pre></p> <p>Or with a delay to ensure Wayland is ready: <pre><code>spawn-at-startup {\n    sleep 1 &amp;&amp; gslapper --restore DP-1\n}\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#other-compositors","title":"Other Compositors","text":"<p>Check your compositor's documentation for how to run commands on startup. Most support <code>exec</code>, <code>exec-once</code>, or <code>spawn-at-startup</code> directives.</p> <p>Advantages: - \u2705 Integrated with compositor - \u2705 Starts with compositor session - \u2705 Simple configuration</p> <p>Disadvantages: - \u274c Compositor-specific (not portable) - \u274c No automatic restart on failure - \u274c Limited process management</p>"},{"location":"user-guide/persistent-wallpapers/#method-4-manual-restoration","title":"Method 4: Manual Restoration","text":"<p>Best for: Testing, one-time setup, troubleshooting</p> <p>Usage: <pre><code># Restore from saved state\ngslapper --restore DP-1\n\n# Or set new wallpaper\ngslapper -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre></p> <p>When to use: - Testing wallpaper settings - One-time wallpaper changes - Troubleshooting state restoration - Temporary wallpapers</p>"},{"location":"user-guide/persistent-wallpapers/#state-management","title":"State Management","text":""},{"location":"user-guide/persistent-wallpapers/#how-state-files-work","title":"How State Files Work","text":"<p>gSlapper automatically saves wallpaper state when you stop it (Ctrl+C) or when it exits:</p> <p>State file location: <pre><code>~/.local/state/gslapper/state-DP-1.txt\n~/.local/state/gslapper/state-DP-3.txt\n~/.local/state/gslapper/state.txt  (for '*' output)\n</code></pre></p> <p>Override with XDG_STATE_HOME: <pre><code># If set, uses $XDG_STATE_HOME/gslapper/ instead\nexport XDG_STATE_HOME=\"$HOME/.local/state\"\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#state-file-format","title":"State File Format","text":"<p>State files use simple key=value text format (human-readable):</p> <pre><code>version=1\noutput=DP-1\npath=/path/to/wallpaper.mp4\nis_image=false\noptions=loop panscan=0.8\nposition=123.45\npaused=0\n</code></pre> <p>Key descriptions: - <code>version</code> - State file format version (currently 1) - <code>output</code> - Monitor name (e.g., \"DP-1\", \"HDMI-1\") - <code>path</code> - Full path to video or image file - <code>is_image</code> - Type indicator (0 = video, 1 = static image) - <code>options</code> - GStreamer options string (e.g., \"loop panscan=0.8\") - <code>position</code> - Video position in seconds (0.0 for images) - <code>paused</code> - Pause state for videos (0 = playing, 1 = paused)</p>"},{"location":"user-guide/persistent-wallpapers/#state-file-security","title":"State File Security","text":"<p>gSlapper uses multiple mechanisms to ensure state file integrity and security:</p>"},{"location":"user-guide/persistent-wallpapers/#atomic-writes","title":"Atomic Writes","text":"<p>State is written to a temporary file first, then renamed: 1. Write to <code>state-&lt;output&gt;.txt.tmp</code> 2. Verify write completed successfully 3. Atomic rename: <code>state-&lt;output&gt;.txt.tmp</code> \u2192 <code>state-&lt;output&gt;.txt</code></p> <p>Benefit: Prevents partial/corrupted state files if power loss or crash occurs during write.</p>"},{"location":"user-guide/persistent-wallpapers/#file-locking","title":"File Locking","text":"<p>State operations use file locking (<code>flock()</code>): - Exclusive lock during writes - Prevents concurrent writes from multiple processes - Blocks until lock is available</p> <p>Benefit: Prevents state corruption when multiple gSlapper instances access same file.</p>"},{"location":"user-guide/persistent-wallpapers/#file-permissions","title":"File Permissions","text":"<p>State files are set to <code>0600</code> (user read/write only): - Owner: Read/Write - Group: No access - Others: No access</p> <p>Benefit: Protects wallpaper paths from other users on shared systems.</p>"},{"location":"user-guide/persistent-wallpapers/#manual-state-management","title":"Manual State Management","text":"<p>Save state manually: <pre><code># Save for current wallpaper and exit\ngslapper --save-state\n</code></pre></p> <p>Restore from state: <pre><code># Restore for specific output\ngslapper --restore DP-1\n\n# Restore from custom state file\ngslapper --restore --state-file /tmp/my-state.txt DP-1\n</code></pre></p> <p>Disable state saving: <pre><code># Prevent automatic state saving on exit\ngslapper --no-save-state -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre></p> <p>Note: The <code>--save-state</code> flag is useful for: - Testing state persistence - Backing up current configuration - Integrating with custom scripts - Debugging state file issues</p>"},{"location":"user-guide/persistent-wallpapers/#multi-monitor-setup","title":"Multi-Monitor Setup","text":""},{"location":"user-guide/persistent-wallpapers/#same-wallpaper-on-all-monitors","title":"Same Wallpaper on All Monitors","text":"<p>Systemd service: <pre><code>ExecStart=/usr/bin/gslapper --systemd --restore '*'\n</code></pre></p> <p>Shell script: <pre><code>gslapper --restore '*' &amp;\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#different-wallpapers-per-monitor","title":"Different Wallpapers per Monitor","text":"<p>Systemd template service: <pre><code># Set wallpapers\ngslapper -o \"loop\" DP-1 /path/to/video1.mp4  # Ctrl+C\ngslapper -o \"fill\" DP-3 /path/to/image.jpg  # Ctrl+C\n\n# Enable services\nsystemctl --user enable --now gslapper@DP-1.service\nsystemctl --user enable --now gslapper@DP-3.service\n</code></pre></p> <p>Shell script: <pre><code>gslapper --restore DP-1 &amp;\ngslapper --restore DP-3 &amp;\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#comparison-of-methods","title":"Comparison of Methods","text":"Method Auto-start Auto-restart State Restore Process Mgmt Complexity Systemd Service \u2705 \u2705 \u2705 \u2705 Medium Shell Script \u2705 \u274c \u2705 \u274c Low Compositor Config \u2705 \u274c \u2705 \u274c Low Manual \u274c \u274c \u2705 \u274c Very Low"},{"location":"user-guide/persistent-wallpapers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/persistent-wallpapers/#wallpaper-not-restoring","title":"Wallpaper Not Restoring","text":"<p>Check state file exists: <pre><code>ls ~/.local/state/gslapper/\n</code></pre></p> <p>Verify state file content: <pre><code>cat ~/.local/state/gslapper/state-DP-1.txt\n</code></pre></p> <p>Check if path still exists: <pre><code># From state file, verify the path is valid\ntest -f /path/to/wallpaper.mp4 &amp;&amp; echo \"Path exists\" || echo \"Path missing\"\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#service-not-starting","title":"Service Not Starting","text":"<p>Check service status: <pre><code>systemctl --user status gslapper.service\n</code></pre></p> <p>View logs: <pre><code>journalctl --user -u gslapper.service -f\n</code></pre></p> <p>Verify environment file: <pre><code>cat ~/.config/gslapper/environment\n# Should contain: WAYLAND_DISPLAY=wayland-0 (or wayland-1)\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#wayland-connection-issues","title":"Wayland Connection Issues","text":"<p>Find your WAYLAND_DISPLAY: <pre><code>echo $WAYLAND_DISPLAY\n</code></pre></p> <p>Update environment file: <pre><code>echo \"WAYLAND_DISPLAY=$WAYLAND_DISPLAY\" &gt; ~/.config/gslapper/environment\n</code></pre></p> <p>For shell scripts, export before running: <pre><code>export WAYLAND_DISPLAY=wayland-0\nexport XDG_RUNTIME_DIR=/run/user/$UID\ngslapper --restore DP-1\n</code></pre></p>"},{"location":"user-guide/persistent-wallpapers/#best-practices","title":"Best Practices","text":"<ol> <li>Always set wallpaper manually first - This creates the state file</li> <li>Use systemd service for production - Best reliability and management</li> <li>Test state restoration - Verify <code>gslapper --restore</code> works before enabling service</li> <li>Keep wallpaper paths stable - Moving files breaks state restoration</li> <li>Use absolute paths - Relative paths may not resolve correctly</li> <li>Check logs regularly - <code>journalctl --user -u gslapper.service</code> for issues</li> </ol>"},{"location":"user-guide/persistent-wallpapers/#see-also","title":"See Also","text":"<ul> <li>Systemd Service Setup - Detailed systemd configuration</li> <li>Video Wallpapers - Video wallpaper guide</li> <li>Static Images - Static image guide</li> <li>Multi-Monitor Setup - Multi-monitor configuration</li> <li>Command Line Options - All available options</li> </ul>"},{"location":"user-guide/scaling-modes/","title":"Scaling Modes","text":"<p>gSlapper provides several scaling modes to control how wallpapers are displayed.</p>"},{"location":"user-guide/scaling-modes/#fill-mode","title":"Fill Mode","text":"<p>Default for images</p> <p>Fills the entire screen while maintaining aspect ratio. Excess content is cropped.</p> <pre><code>gslapper -o \"fill\" DP-1 /path/to/image.jpg\n</code></pre> <p>Use case: Best for wallpapers where you want full screen coverage and don't mind cropping.</p>"},{"location":"user-guide/scaling-modes/#stretch-mode","title":"Stretch Mode","text":"<p>Fills the entire screen ignoring aspect ratio. Content may appear distorted.</p> <pre><code>gslapper -o \"stretch\" DP-1 /path/to/image.jpg\n</code></pre> <p>Use case: When you want full coverage and don't care about aspect ratio.</p>"},{"location":"user-guide/scaling-modes/#original-mode","title":"Original Mode","text":"<p>Displays at native resolution with 1:1 pixel mapping. May show letterboxing/pillarboxing.</p> <pre><code>gslapper -o \"original\" DP-1 /path/to/image.jpg\n</code></pre> <p>Use case: When you want to see the image exactly as it was created, pixel-perfect.</p>"},{"location":"user-guide/scaling-modes/#panscan-mode","title":"Panscan Mode","text":"<p>Default for videos</p> <p>Fits content inside the screen with a scaling factor (0.0 to 1.0).</p> <pre><code># Scale to 100% (fit to screen)\ngslapper -o \"panscan=1.0\" DP-1 /path/to/video.mp4\n\n# Scale to 80%\ngslapper -o \"panscan=0.8\" DP-1 /path/to/video.mp4\n</code></pre> <p>Use case: For videos where you want to control the zoom level while maintaining aspect ratio.</p>"},{"location":"user-guide/scaling-modes/#comparison","title":"Comparison","text":"Mode Aspect Ratio Coverage Distortion Fill Maintained Full None Stretch Ignored Full Possible Original Maintained Partial None Panscan Maintained Variable None"},{"location":"user-guide/scaling-modes/#recommendations","title":"Recommendations","text":"<ul> <li>Images: Use <code>fill</code> for most cases</li> <li>Videos: Use <code>panscan=1.0</code> (default) for best results</li> <li>Artwork: Use <code>original</code> to preserve pixel-perfect rendering</li> </ul>"},{"location":"user-guide/static-images/","title":"Static Images","text":"<p>gSlapper supports static images with automatic format detection and multiple scaling modes.</p>"},{"location":"user-guide/static-images/#supported-formats","title":"Supported Formats","text":"<ul> <li>JPEG (.jpg, .jpeg)</li> <li>PNG (.png)</li> <li>WebP (.webp)</li> <li>GIF (.gif) - First frame only</li> </ul>"},{"location":"user-guide/static-images/#basic-usage","title":"Basic Usage","text":"<pre><code>gslapper DP-1 /path/to/wallpaper.jpg\n</code></pre> <p>Images default to fill mode, which fills the screen while maintaining aspect ratio (cropping excess).</p>"},{"location":"user-guide/static-images/#scaling-modes","title":"Scaling Modes","text":""},{"location":"user-guide/static-images/#fill-mode-default","title":"Fill Mode (Default)","text":"<p>Fills the screen maintaining aspect ratio, crops excess:</p> <pre><code>gslapper -o \"fill\" DP-1 /path/to/image.png\n</code></pre>"},{"location":"user-guide/static-images/#stretch-mode","title":"Stretch Mode","text":"<p>Fills screen ignoring aspect ratio:</p> <pre><code>gslapper -o \"stretch\" DP-1 /path/to/image.png\n</code></pre>"},{"location":"user-guide/static-images/#original-resolution","title":"Original Resolution","text":"<p>Display at native resolution (1:1 pixel mapping):</p> <pre><code>gslapper -o \"original\" DP-1 /path/to/image.png\n</code></pre>"},{"location":"user-guide/static-images/#panscan-mode","title":"Panscan Mode","text":"<p>Fit inside screen with scaling factor:</p> <pre><code>gslapper -o \"panscan=0.8\" DP-1 /path/to/image.png\n</code></pre>"},{"location":"user-guide/static-images/#multiple-monitors","title":"Multiple Monitors","text":"<pre><code># Same image on all monitors\ngslapper -o \"fill\" '*' /path/to/wallpaper.jpg\n\n# Different images per monitor\ngslapper -o \"fill\" DP-1 /path/to/image1.jpg &amp;\ngslapper -o \"fill\" DP-3 /path/to/image2.jpg &amp;\n</code></pre>"},{"location":"user-guide/static-images/#transitions","title":"Transitions","text":"<p>gSlapper supports smooth fade transitions between images. See Transitions for details.</p>"},{"location":"user-guide/static-images/#making-image-wallpapers-persistent","title":"Making Image Wallpapers Persistent","text":"<p>To make your image wallpaper automatically restore after reboot or login, see the Persistent Wallpapers guide. The guide covers multiple methods including systemd service setup, shell scripts, and compositor-specific configuration.</p>"},{"location":"user-guide/video-wallpapers/","title":"Video Wallpapers","text":"<p>gSlapper supports all video formats that GStreamer can decode, including MP4, MKV, WebM, AVI, MOV, and more.</p>"},{"location":"user-guide/video-wallpapers/#basic-usage","title":"Basic Usage","text":"<pre><code>gslapper DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#looping","title":"Looping","text":"<p>To loop a video seamlessly:</p> <pre><code>gslapper -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#scaling-options","title":"Scaling Options","text":""},{"location":"user-guide/video-wallpapers/#fit-to-screen-default","title":"Fit to Screen (Default)","text":"<pre><code>gslapper -o \"loop panscan=1.0\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#scale-with-factor","title":"Scale with Factor","text":"<pre><code># Scale to 80% of screen size\ngslapper -o \"loop panscan=0.8\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#stretch-to-fill","title":"Stretch to Fill","text":"<pre><code>gslapper -o \"loop stretch\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#original-resolution","title":"Original Resolution","text":"<pre><code>gslapper -o \"loop original\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#multiple-monitors","title":"Multiple Monitors","text":""},{"location":"user-guide/video-wallpapers/#same-video-on-all-monitors","title":"Same Video on All Monitors","text":"<pre><code>gslapper -o \"loop\" '*' /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#different-videos-per-monitor","title":"Different Videos per Monitor","text":"<pre><code>gslapper -o \"loop\" DP-1 /path/to/video1.mp4 &amp;\ngslapper -o \"loop\" DP-3 /path/to/video2.mp4 &amp;\n</code></pre>"},{"location":"user-guide/video-wallpapers/#audio","title":"Audio","text":"<p>By default, audio is enabled. To disable:</p> <pre><code>gslapper -o \"loop no-audio\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#background-mode","title":"Background Mode","text":"<p>Run in the background:</p> <pre><code>gslapper -f -o \"loop\" DP-1 /path/to/video.mp4\n</code></pre>"},{"location":"user-guide/video-wallpapers/#supported-formats","title":"Supported Formats","text":"<ul> <li>MP4 (H.264, H.265)</li> <li>MKV</li> <li>WebM</li> <li>AVI</li> <li>MOV</li> <li>Any format supported by GStreamer</li> </ul> <p>Codec Support</p> <p>Ensure you have <code>gst-plugins-ugly</code> and <code>gst-libav</code> installed for H.264/H.265 support.</p>"},{"location":"user-guide/video-wallpapers/#making-video-wallpapers-persistent","title":"Making Video Wallpapers Persistent","text":"<p>To make your video wallpaper automatically restore after reboot or login, see the Persistent Wallpapers guide. The guide covers multiple methods including systemd service setup, shell scripts, and compositor-specific configuration.</p>"}]}